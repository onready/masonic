{"version":3,"file":"index.mjs","sources":["../../src/use-scroller.ts","../../src/use-force-update.ts","../../src/use-masonry.tsx","../../src/masonry-scroller.tsx","../../src/use-container-position.ts","../../src/use-resize-observer.ts","../../src/interval-tree.ts","../../src/use-positioner.ts","../../src/use-scroll-to-index.ts","../../src/masonry.tsx","../../src/list.tsx","../../src/use-infinite-loader.ts","../../src/elements-cache.ts"],"sourcesContent":["import * as React from 'react'\r\nimport useScrollPosition from '@react-hook/window-scroll'\r\nimport {requestTimeout, clearRequestTimeout} from '@essentials/request-timeout'\r\n\r\n/**\r\n * A hook for tracking whether the `window` is currently being scrolled and it's scroll position on\r\n * the y-axis. These values are used for determining which grid cells to render and when\r\n * to add styles to the masonry container that maximize scroll performance.\r\n *\r\n * @param offset The vertical space in pixels between the top of the grid container and the top\r\n *  of the browser `document.documentElement`.\r\n * @param fps This determines how often (in frames per second) to update the scroll position of the\r\n *  browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\r\n *  The default value of `12` has been very reasonable in my own testing, but if you have particularly\r\n *  heavy `render` components it may be prudent to reduce this number.\r\n */\r\nexport function useScroller(\r\n  offset = 0,\r\n  fps = 12\r\n): {scrollTop: number; isScrolling: boolean} {\r\n  const scrollTop = useScrollPosition(fps)\r\n  const [isScrolling, setIsScrolling] = React.useState(false)\r\n  const didMount = React.useRef(0)\r\n\r\n  React.useEffect(() => {\r\n    if (didMount.current === 1) setIsScrolling(true)\r\n    const to = requestTimeout(() => {\r\n      // This is here to prevent premature bail outs while maintaining high resolution\r\n      // unsets. Without it there will always bee a lot of unnecessary DOM writes to style.\r\n      setIsScrolling(false)\r\n    }, 40 + 1000 / fps)\r\n    didMount.current = 1\r\n    return () => clearRequestTimeout(to)\r\n  }, [fps, scrollTop])\r\n\r\n  return {scrollTop: Math.max(0, scrollTop - offset), isScrolling}\r\n}\r\n","import * as React from 'react'\r\n\r\nexport function useForceUpdate() {\r\n  const setState = React.useState(emptyObj)[1]\r\n  return React.useRef(() => setState({})).current\r\n}\r\n\r\nconst emptyObj = {}\r\n","import * as React from 'react'\r\nimport trieMemoize from 'trie-memoize'\r\nimport OneKeyMap from '@essentials/one-key-map'\r\nimport memoizeOne from '@essentials/memoize-one'\r\nimport useLatest from '@react-hook/latest'\r\nimport {elementsCache} from './elements-cache'\r\nimport {useForceUpdate} from './use-force-update'\r\nimport type {Positioner} from './use-positioner'\r\n\r\n/**\r\n * This hook handles the render phases of the masonry layout and returns the grid as a React element.\r\n *\r\n * @param options Options for configuring the masonry layout renderer. See `UseMasonryOptions`.\r\n */\r\nexport function useMasonry<Item>({\r\n  // Measurement and layout\r\n  positioner,\r\n  resizeObserver,\r\n  // Grid items\r\n  items,\r\n  // Container props\r\n  as: ContainerComponent = 'div',\r\n  id,\r\n  className,\r\n  style,\r\n  role = 'grid',\r\n  tabIndex = 0,\r\n  containerRef,\r\n  // Item props\r\n  itemAs: ItemComponent = 'div',\r\n  itemStyle,\r\n  itemHeightEstimate = 300,\r\n  itemKey = defaultGetItemKey,\r\n  // Rendering props\r\n  overscanBy = 2,\r\n  scrollTop,\r\n  isScrolling,\r\n  height,\r\n  render: RenderComponent,\r\n  onRender,\r\n}: UseMasonryOptions<Item>) {\r\n  let startIndex = 0\r\n  let stopIndex: number | undefined = void 0\r\n  const forceUpdate = useForceUpdate()\r\n  const setItemRef = getRefSetter(positioner, resizeObserver)\r\n  const itemCount = items.length\r\n  const {\r\n    columnWidth,\r\n    columnCount,\r\n    range,\r\n    estimateHeight,\r\n    size,\r\n    shortestColumn,\r\n  } = positioner\r\n  const measuredCount = size()\r\n  const shortestColumnSize = shortestColumn()\r\n  const children: React.ReactElement[] = []\r\n  const itemRole = role + 'item'\r\n  const storedOnRender = useLatest(onRender)\r\n\r\n  overscanBy = height * overscanBy\r\n  const rangeEnd = scrollTop + overscanBy\r\n  const needsFreshBatch =\r\n    shortestColumnSize < rangeEnd && measuredCount < itemCount\r\n\r\n  range(\r\n    // We overscan in both directions because users scroll both ways,\r\n    // though one must admit scrolling down is more common and thus\r\n    // we only overscan by half the downward overscan amount\r\n    Math.max(0, scrollTop - overscanBy / 2),\r\n    rangeEnd,\r\n    (index, left, top) => {\r\n      const data = items[index]\r\n      const key = itemKey(data, index)\r\n      const phaseTwoStyle: React.CSSProperties = {\r\n        top,\r\n        left,\r\n        width: columnWidth,\r\n        writingMode: 'horizontal-tb',\r\n        position: 'absolute',\r\n      }\r\n\r\n      /* istanbul ignore next */\r\n      if (\r\n        typeof process !== 'undefined' &&\r\n        process.env.NODE_ENV !== 'production'\r\n      ) {\r\n        throwWithoutData(data, index)\r\n      }\r\n\r\n      children.push(\r\n        <ItemComponent\r\n          key={key}\r\n          ref={setItemRef(index)}\r\n          role={itemRole}\r\n          style={\r\n            typeof itemStyle === 'object' && itemStyle !== null\r\n              ? Object.assign({}, phaseTwoStyle, itemStyle)\r\n              : phaseTwoStyle\r\n          }\r\n        >\r\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\r\n        </ItemComponent>\r\n      )\r\n\r\n      if (stopIndex === void 0) {\r\n        startIndex = index\r\n        stopIndex = index\r\n      } else {\r\n        startIndex = Math.min(startIndex, index)\r\n        stopIndex = Math.max(stopIndex, index)\r\n      }\r\n    }\r\n  )\r\n\r\n  if (needsFreshBatch) {\r\n    const batchSize = Math.min(\r\n      itemCount - measuredCount,\r\n      Math.ceil(\r\n        ((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate) *\r\n          columnCount\r\n      )\r\n    )\r\n\r\n    let index = measuredCount\r\n    const phaseOneStyle = getCachedSize(columnWidth)\r\n\r\n    for (; index < measuredCount + batchSize; index++) {\r\n      const data = items[index]\r\n      const key = itemKey(data, index)\r\n\r\n      /* istanbul ignore next */\r\n      if (\r\n        typeof process !== 'undefined' &&\r\n        process.env.NODE_ENV !== 'production'\r\n      ) {\r\n        throwWithoutData(data, index)\r\n      }\r\n\r\n      children.push(\r\n        <ItemComponent\r\n          key={key}\r\n          ref={setItemRef(index)}\r\n          role={itemRole}\r\n          style={\r\n            typeof itemStyle === 'object'\r\n              ? Object.assign({}, phaseOneStyle, itemStyle)\r\n              : phaseOneStyle\r\n          }\r\n        >\r\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\r\n        </ItemComponent>\r\n      )\r\n    }\r\n  }\r\n\r\n  // Calls the onRender callback if the rendered indices changed\r\n  React.useEffect(() => {\r\n    if (typeof storedOnRender.current === 'function' && stopIndex !== void 0)\r\n      storedOnRender.current(startIndex, stopIndex, items)\r\n\r\n    didEverMount = '1'\r\n  }, [startIndex, stopIndex, items, storedOnRender])\r\n  // If we needed a fresh batch we should reload our components with the measured\r\n  // sizes\r\n  React.useEffect(() => {\r\n    if (needsFreshBatch) forceUpdate()\r\n    // eslint-disable-next-line\r\n  }, [needsFreshBatch])\r\n\r\n  // gets the container style object based upon the estimated height and whether or not\r\n  // the page is being scrolled\r\n  const containerStyle = getContainerStyle(\r\n    isScrolling,\r\n    estimateHeight(itemCount, itemHeightEstimate)\r\n  )\r\n\r\n  return (\r\n    <ContainerComponent\r\n      ref={containerRef}\r\n      key={didEverMount}\r\n      id={id}\r\n      role={role}\r\n      className={className}\r\n      tabIndex={tabIndex}\r\n      style={\r\n        typeof style === 'object'\r\n          ? assignUserStyle(containerStyle, style)\r\n          : containerStyle\r\n      }\r\n      children={children}\r\n    />\r\n  )\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction throwWithoutData(data: any, index: number) {\r\n  if (!data) {\r\n    throw new Error(\r\n      `No data was found at index: ${index}\\n\\n` +\r\n        `This usually happens when you've mutated or changed the \"items\" array in a ` +\r\n        `way that makes it shorter than the previous \"items\" array. Masonic knows nothing ` +\r\n        `about your underlying data and when it caches cell positions, it assumes you aren't ` +\r\n        `mutating the underlying \"items\".\\n\\n` +\r\n        `See https://codesandbox.io/s/masonic-w-react-router-example-2b5f9?file=/src/index.js for ` +\r\n        `an example that gets around this limitations. For advanced implementations, see ` +\r\n        `https://codesandbox.io/s/masonic-w-react-router-and-advanced-config-example-8em42?file=/src/index.js\\n\\n` +\r\n        `If this was the result of your removing an item from your \"items\", see this issue: ` +\r\n        `https://github.com/jaredLunde/masonic/issues/12`\r\n    )\r\n  }\r\n}\r\n\r\n// This is for triggering a remount after SSR has loaded in the client w/ hydrate()\r\nlet didEverMount = '0'\r\n\r\nexport interface UseMasonryOptions<Item> {\r\n  /**\r\n   * An array containing the data used by the grid items.\r\n   */\r\n  items: Item[]\r\n  /**\r\n   * A grid cell positioner and cache created by the `usePositioner()` hook or\r\n   * the `createPositioner` utility.\r\n   */\r\n  positioner: Positioner\r\n  /**\r\n   * A resize observer that tracks mutations to the grid cells and forces the\r\n   * Masonry grid to recalculate its layout if any cells affect column heights\r\n   * change. Check out the `useResizeObserver()` hook.\r\n   */\r\n  resizeObserver?: {\r\n    observe: ResizeObserver['observe']\r\n    disconnect: ResizeObserver['observe']\r\n    unobserve: ResizeObserver['unobserve']\r\n  }\r\n  /**\r\n   * This is the type of element the grid container will be rendered as.\r\n   * @default \"div\"`\r\n   */\r\n  as?: keyof JSX.IntrinsicElements | React.ComponentType<any>\r\n  /**\r\n   * Optionally gives the grid container an `id` prop.\r\n   */\r\n  id?: string\r\n  /**\r\n   * Optionally gives the grid container a `className` prop.\r\n   */\r\n  className?: string\r\n  /**\r\n   * Adds extra `style` attributes to the container in addition to those\r\n   * created by the `useMasonry()` hook.\r\n   */\r\n  style?: React.CSSProperties\r\n  /**\r\n   * Optionally swap out the accessibility `role` prop of the container and its items.\r\n   * @default \"grid\"\r\n   */\r\n  role?: 'grid' | 'list'\r\n  /**\r\n   * Change the `tabIndex` of the grid container.\r\n   * @default 0\r\n   */\r\n  tabIndex?: number\r\n  /**\r\n   * Forwards a React ref to the grid container.\r\n   */\r\n  containerRef?:\r\n    | ((element: HTMLElement) => void)\r\n    | React.MutableRefObject<HTMLElement | null>\r\n  /**\r\n   * This is the type of element the grid items will be rendered as.\r\n   * @default \"div\"\r\n   */\r\n  itemAs?: keyof JSX.IntrinsicElements | React.ComponentType<any>\r\n  /**\r\n   * Adds extra `style` attributes to the grid items in addition to those\r\n   * created by the `useMasonry()` hook.\r\n   */\r\n  itemStyle?: React.CSSProperties\r\n  /**\r\n   * This value is used for estimating the initial height of the masonry grid. It is important for\r\n   * the UX of the scrolling behavior and in determining how many `items` to render in a batch, so it's\r\n   * wise to set this value with some level accuracy, though it doesn't need to be perfect.\r\n   * @default 300\r\n   */\r\n  itemHeightEstimate?: number\r\n  /**\r\n   * The value returned here must be unique to the item. By default, the key is the item's index. This is ok\r\n   * if your collection of items is never modified. Setting this property ensures that the component in `render`\r\n   * is reused each time the masonry grid is reflowed. A common pattern would be to return the item's database\r\n   * ID here if there is one, e.g. `data => data.id`\r\n   * @default (data, index) => index`\r\n   */\r\n  itemKey?: (data: Item, index: number) => string | number\r\n  /**\r\n   * This number is used for determining the number of grid cells outside of the visible window to render.\r\n   * The default value is `2` which means \"render 2 windows worth (2 * `height`) of content before and after\r\n   * the items in the visible window\". A value of `3` would be 3 windows worth of grid cells, so it's a\r\n   * linear relationship.\r\n   *\r\n   * Overscanning is important for preventing tearing when scrolling through items in the grid, but setting\r\n   * too high of a vaimport { useForceUpdate } from './use-force-update';\r\nlue may create too much work for React to handle, so it's best that you tune this\r\n   * value accordingly.\r\n   * @default 2\r\n   */\r\n  overscanBy?: number\r\n\r\n  /**\r\n   * This is the height of the window. If you're rendering the grid relative to the browser `window`,\r\n   * the current `document.documentElement.clientHeight` is the value you'll want to set here. If you're\r\n   * rendering the grid inside of another HTML element, you'll want to provide the current `element.offsetHeight`\r\n   * here.\r\n   */\r\n  height: number\r\n  /**\r\n   * The current scroll progress in pixel of the window the grid is rendered in. If you're rendering\r\n   * the grid relative to the browser `window`, you'll want the most current `window.scrollY` here.\r\n   * If you're rendering the grid inside of another HTML element, you'll want the current `element.scrollTop`\r\n   * value here. The `useScroller()` hook and `<MasonryScroller>` components will help you if you're\r\n   * rendering the grid relative to the browser `window`.\r\n   */\r\n  scrollTop: number\r\n  /**\r\n   * This property is used for determining whether or not the grid container should add styles that\r\n   * dramatically increase scroll performance. That is, turning off `pointer-events` and adding a\r\n   * `will-change: contents;` value to the style string. You can forgo using this prop, but I would\r\n   * not recommend that. The `useScroller()` hook and `<MasonryScroller>` components will help you if\r\n   * you're rendering the grid relative to the browser `window`.\r\n   * @default false\r\n   */\r\n  isScrolling?: boolean\r\n  /**\r\n   * This component is rendered for each item of your `items` prop array. It should accept three props:\r\n   * `index`, `width`, and `data`. See RenderComponentProps.\r\n   */\r\n  render: React.ComponentType<RenderComponentProps<Item>>\r\n  /**\r\n   * This callback is invoked any time the items currently being rendered by the grid change.\r\n   */\r\n  onRender?: (\r\n    startIndex: number,\r\n    stopIndex: number | undefined,\r\n    items: Item[]\r\n  ) => void\r\n}\r\n\r\nexport interface RenderComponentProps<Item> {\r\n  /**\r\n   * The index of the cell in the `items` prop array.\r\n   */\r\n  index: number\r\n  /**\r\n   * The rendered width of the cell's column.\r\n   */\r\n  width: number\r\n  /**\r\n   * The data at `items[index]` of your `items` prop array.\r\n   */\r\n  data: Item\r\n}\r\n\r\n//\r\n// Render-phase utilities\r\n\r\n// ~5.5x faster than createElement without the memo\r\nconst createRenderElement = trieMemoize(\r\n  [OneKeyMap, {}, WeakMap, OneKeyMap],\r\n  (RenderComponent, index, data, columnWidth) => (\r\n    <RenderComponent index={index} data={data} width={columnWidth} />\r\n  )\r\n)\r\n\r\nconst getContainerStyle = memoizeOne(\r\n  (isScrolling: boolean | undefined, estimateHeight: number) => ({\r\n    position: 'relative',\r\n    width: '100%',\r\n    maxWidth: '100%',\r\n    height: Math.ceil(estimateHeight),\r\n    maxHeight: Math.ceil(estimateHeight),\r\n    willChange: isScrolling ? 'contents' : void 0,\r\n    pointerEvents: isScrolling ? 'none' : void 0,\r\n  })\r\n)\r\n\r\nconst cmp2 = (args: IArguments, pargs: IArguments | any[]): boolean =>\r\n  args[0] === pargs[0] && args[1] === pargs[1]\r\n\r\nconst assignUserStyle = memoizeOne(\r\n  (containerStyle, userStyle) => Object.assign({}, containerStyle, userStyle),\r\n  // @ts-ignore\r\n  cmp2\r\n)\r\n\r\nfunction defaultGetItemKey<Item>(_: Item, i: number) {\r\n  return i\r\n}\r\n\r\n// the below memoizations for for ensuring shallow equal is reliable for pure\r\n// component children\r\nconst getCachedSize = memoizeOne(\r\n  (width: number): React.CSSProperties => ({\r\n    width,\r\n    zIndex: -1000,\r\n    visibility: 'hidden',\r\n    position: 'absolute',\r\n    writingMode: 'horizontal-tb',\r\n  }),\r\n  (args, pargs) => args[0] === pargs[0]\r\n)\r\n\r\nconst getRefSetter = memoizeOne(\r\n  (\r\n    positioner: Positioner,\r\n    resizeObserver?: UseMasonryOptions<any>['resizeObserver']\r\n  ) => (index: number) => (el: HTMLElement | null): void => {\r\n    if (el === null) return\r\n    if (resizeObserver) {\r\n      resizeObserver.observe(el)\r\n      elementsCache.set(el, index)\r\n    }\r\n    if (positioner.get(index) === void 0) positioner.set(index, el.offsetHeight)\r\n  },\r\n  // @ts-ignore\r\n  cmp2\r\n)\r\n","import {useScroller} from './use-scroller'\r\nimport {useMasonry} from './use-masonry'\r\nimport type {UseMasonryOptions} from './use-masonry'\r\n/**\r\n * A heavily-optimized component that updates `useMasonry()` when the scroll position of the browser `window`\r\n * changes. This bare-metal component is used by `<Masonry>` under the hood.\r\n */\r\nexport function MasonryScroller<Item>(props: MasonryScrollerProps<Item>) {\r\n  // We put this in its own layer because it's the thing that will trigger the most updates\r\n  // and we don't want to slower ourselves by cycling through all the functions, objects, and effects\r\n  // of other hooks\r\n  const {scrollTop, isScrolling} = useScroller(props.offset, props.scrollFps)\r\n  // This is an update-heavy phase and while we could just Object.assign here,\r\n  // it is way faster to inline and there's a relatively low hit to he bundle\r\n  // size.\r\n  return useMasonry<Item>({\r\n    scrollTop,\r\n    isScrolling,\r\n    positioner: props.positioner,\r\n    resizeObserver: props.resizeObserver,\r\n    items: props.items,\r\n    onRender: props.onRender,\r\n    as: props.as,\r\n    id: props.id,\r\n    className: props.className,\r\n    style: props.style,\r\n    role: props.role,\r\n    tabIndex: props.tabIndex,\r\n    containerRef: props.containerRef,\r\n    itemAs: props.itemAs,\r\n    itemStyle: props.itemStyle,\r\n    itemHeightEstimate: props.itemHeightEstimate,\r\n    itemKey: props.itemKey,\r\n    overscanBy: props.overscanBy,\r\n    height: props.height,\r\n    render: props.render,\r\n  })\r\n}\r\n\r\nexport interface MasonryScrollerProps<Item>\r\n  extends Omit<UseMasonryOptions<Item>, 'scrollTop' | 'isScrolling'> {\r\n  /**\r\n   * This determines how often (in frames per second) to update the scroll position of the\r\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\r\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\r\n   * heavy `render` components it may be prudent to reduce this number.\r\n   * @default 12\r\n   */\r\n  scrollFps?: number\r\n  /**\r\n   * The vertical space in pixels between the top of the grid container and the top\r\n   * of the browser `document.documentElement`.\r\n   * @default 0\r\n   */\r\n  offset?: number\r\n}\r\n\r\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\r\n  MasonryScroller.displayName = 'MasonryScroller'\r\n}\r\n","import * as React from 'react'\r\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\r\n\r\n/**\r\n * A hook for measuring the width of the grid container, as well as its distance\r\n * from the top of the document. These values are necessary to correctly calculate the number/width\r\n * of columns to render, as well as the number of rows to render.\r\n *\r\n * @param elementRef A `ref` object created by `React.useRef()`. That ref should be provided to the\r\n *   `containerRef` property in `useMasonry()`.\r\n * @param deps You can force this hook to recalculate the `offset` and `width` whenever this\r\n *   dependencies list changes. A common dependencies list might look like `[windowWidth, windowHeight]`,\r\n *   which would force the hook to recalculate any time the size of the browser `window` changed.\r\n */\r\nexport function useContainerPosition(\r\n  elementRef: React.MutableRefObject<HTMLElement | null>,\r\n  deps: React.DependencyList = emptyArr\r\n): ContainerPosition {\r\n  const [containerPosition, setContainerPosition] = React.useState<\r\n    ContainerPosition\r\n  >({offset: 0, width: 0})\r\n\r\n  useLayoutEffect(() => {\r\n    const {current} = elementRef\r\n    if (current !== null) {\r\n      let offset = 0\r\n      let el = current\r\n\r\n      do {\r\n        offset += el.offsetTop || 0\r\n        el = el.offsetParent as HTMLElement\r\n      } while (el)\r\n\r\n      if (\r\n        offset !== containerPosition.offset ||\r\n        current.offsetWidth !== containerPosition.width\r\n      ) {\r\n        setContainerPosition({\r\n          offset,\r\n          width: current.offsetWidth,\r\n        })\r\n      }\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, deps)\r\n\r\n  return containerPosition\r\n}\r\n\r\nexport interface ContainerPosition {\r\n  /**\r\n   * The distance in pixels between the top of the element in `elementRef` and the top of\r\n   * the `document.documentElement`.\r\n   */\r\n  offset: number\r\n  /**\r\n   * The `offsetWidth` of the element in `elementRef`.\r\n   */\r\n  width: number\r\n}\r\n\r\nconst emptyArr: [] = []\r\n","import * as React from 'react'\r\nimport trieMemoize from 'trie-memoize'\r\nimport ResizeObserver from 'resize-observer-polyfill'\r\nimport {elementsCache} from './elements-cache'\r\nimport {useForceUpdate} from './use-force-update'\r\nimport type {Positioner} from './use-positioner'\r\n\r\n/**\r\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\r\n * made to cells affecting their height.\r\n *\r\n * @param positioner The masonry cell positioner created by the `usePositioner()` hook.\r\n */\r\nexport function useResizeObserver(positioner: Positioner) {\r\n  const forceUpdate = useForceUpdate()\r\n  const resizeObserver = createResizeObserver(positioner, forceUpdate)\r\n  // Cleans up the resize observers when they change or the\r\n  // component unmounts\r\n  React.useEffect(() => () => resizeObserver.disconnect(), [resizeObserver])\r\n  return resizeObserver\r\n}\r\n\r\n/**\r\n * Creates a resize observer that fires an `updater` callback whenever the height of\r\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\r\n *\r\n * @param positioner A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\r\n * @param updater A callback that fires whenever one or many cell heights change.\r\n */\r\nexport const createResizeObserver = trieMemoize(\r\n  [WeakMap],\r\n  // TODO: figure out a way to test this\r\n  /* istanbul ignore next */\r\n  (positioner: Positioner, updater: (updates: number[]) => void) =>\r\n    new ResizeObserver((entries) => {\r\n      const updates: number[] = []\r\n      let i = 0\r\n\r\n      for (; i < entries.length; i++) {\r\n        const entry = entries[i]\r\n        const height = (entry.target as HTMLElement).offsetHeight\r\n\r\n        if (height > 0) {\r\n          const index = elementsCache.get(entry.target)\r\n\r\n          if (index !== void 0) {\r\n            const position = positioner.get(index)\r\n\r\n            if (position !== void 0 && height !== position.height)\r\n              updates.push(index, height)\r\n          }\r\n        }\r\n      }\r\n\r\n      if (updates.length > 0) {\r\n        // Updates the size/positions of the cell with the resize\r\n        // observer updates\r\n        positioner.update(updates)\r\n        updater(updates)\r\n      }\r\n    })\r\n)\r\n\r\ninterface ResizeObserverEntryBoxSize {\r\n  blockSize: number\r\n  inlineSize: number\r\n}\r\n\r\ninterface NativeResizeObserverEntry extends ResizeObserverEntry {\r\n  borderBoxSize: ResizeObserverEntryBoxSize\r\n  contentBoxSize: ResizeObserverEntryBoxSize\r\n}\r\n","type Color = 0 | 1 | 2\r\nconst RED = 0\r\nconst BLACK = 1\r\nconst NIL = 2\r\n\r\nconst DELETE = 0\r\nconst KEEP = 1\r\n\r\ntype ListNode = {\r\n  index: number\r\n  high: number\r\n  next: ListNode | null\r\n}\r\n\r\ninterface TreeNode {\r\n  max: number\r\n  low: number\r\n  high: number\r\n  // color\r\n  C: Color\r\n  // P\r\n  P: TreeNode\r\n  // right\r\n  R: TreeNode\r\n  // left\r\n  L: TreeNode\r\n  list: ListNode\r\n}\r\n\r\ninterface Tree {\r\n  root: TreeNode\r\n  size: number\r\n}\r\n\r\nfunction addInterval(treeNode: TreeNode, high: number, index: number): boolean {\r\n  let node: ListNode | null = treeNode.list\r\n  let prevNode: ListNode | undefined\r\n\r\n  while (node) {\r\n    if (node.index === index) return false\r\n    if (high > node.high) break\r\n    prevNode = node\r\n    node = node.next\r\n  }\r\n\r\n  if (!prevNode) treeNode.list = {index, high, next: node}\r\n  if (prevNode) prevNode.next = {index, high, next: prevNode.next}\r\n\r\n  return true\r\n}\r\n\r\nfunction removeInterval(treeNode: TreeNode, index: number) {\r\n  let node: ListNode | null = treeNode.list\r\n  if (node.index === index) {\r\n    if (node.next === null) return DELETE\r\n    treeNode.list = node.next\r\n    return KEEP\r\n  }\r\n\r\n  let prevNode: ListNode | undefined = node\r\n  node = node.next\r\n\r\n  while (node !== null) {\r\n    if (node.index === index) {\r\n      prevNode.next = node.next\r\n      return KEEP\r\n    }\r\n    prevNode = node\r\n    node = node.next\r\n  }\r\n}\r\n\r\nconst NULL_NODE: TreeNode = {\r\n  low: 0,\r\n  max: 0,\r\n  high: 0,\r\n  C: NIL,\r\n  // @ts-ignore\r\n  P: undefined,\r\n  // @ts-ignore\r\n  R: undefined,\r\n  // @ts-ignore\r\n  L: undefined,\r\n  // @ts-ignore\r\n  list: undefined,\r\n}\r\n\r\nNULL_NODE.P = NULL_NODE\r\nNULL_NODE.L = NULL_NODE\r\nNULL_NODE.R = NULL_NODE\r\n\r\nfunction updateMax(node: TreeNode) {\r\n  const max = node.high\r\n  if (node.L === NULL_NODE && node.R === NULL_NODE) node.max = max\r\n  else if (node.L === NULL_NODE) node.max = Math.max(node.R.max, max)\r\n  else if (node.R === NULL_NODE) node.max = Math.max(node.L.max, max)\r\n  else node.max = Math.max(Math.max(node.L.max, node.R.max), max)\r\n}\r\n\r\nfunction updateMaxUp(node: TreeNode) {\r\n  let x = node\r\n\r\n  while (x.P !== NULL_NODE) {\r\n    updateMax(x.P)\r\n    x = x.P\r\n  }\r\n}\r\n\r\nfunction rotateLeft(tree: Tree, x: TreeNode) {\r\n  if (x.R === NULL_NODE) return\r\n  const y = x.R\r\n  x.R = y.L\r\n  if (y.L !== NULL_NODE) y.L.P = x\r\n  y.P = x.P\r\n\r\n  if (x.P === NULL_NODE) tree.root = y\r\n  else {\r\n    if (x === x.P.L) x.P.L = y\r\n    else x.P.R = y\r\n  }\r\n\r\n  y.L = x\r\n  x.P = y\r\n\r\n  updateMax(x)\r\n  updateMax(y)\r\n}\r\n\r\nfunction rotateRight(tree: Tree, x: TreeNode) {\r\n  if (x.L === NULL_NODE) return\r\n  const y = x.L\r\n  x.L = y.R\r\n  if (y.R !== NULL_NODE) y.R.P = x\r\n  y.P = x.P\r\n\r\n  if (x.P === NULL_NODE) tree.root = y\r\n  else {\r\n    if (x === x.P.R) x.P.R = y\r\n    else x.P.L = y\r\n  }\r\n\r\n  y.R = x\r\n  x.P = y\r\n\r\n  updateMax(x)\r\n  updateMax(y)\r\n}\r\n\r\nfunction replaceNode(tree: Tree, x: TreeNode, y: TreeNode) {\r\n  if (x.P === NULL_NODE) tree.root = y\r\n  else if (x === x.P.L) x.P.L = y\r\n  else x.P.R = y\r\n  y.P = x.P\r\n}\r\n\r\nfunction fixRemove(tree: Tree, x: TreeNode) {\r\n  let w\r\n\r\n  while (x !== NULL_NODE && x.C === BLACK) {\r\n    if (x === x.P.L) {\r\n      w = x.P.R\r\n\r\n      if (w.C === RED) {\r\n        w.C = BLACK\r\n        x.P.C = RED\r\n        rotateLeft(tree, x.P)\r\n        w = x.P.R\r\n      }\r\n\r\n      if (w.L.C === BLACK && w.R.C === BLACK) {\r\n        w.C = RED\r\n        x = x.P\r\n      } else {\r\n        if (w.R.C === BLACK) {\r\n          w.L.C = BLACK\r\n          w.C = RED\r\n          rotateRight(tree, w)\r\n          w = x.P.R\r\n        }\r\n\r\n        w.C = x.P.C\r\n        x.P.C = BLACK\r\n        w.R.C = BLACK\r\n        rotateLeft(tree, x.P)\r\n        x = tree.root\r\n      }\r\n    } else {\r\n      w = x.P.L\r\n\r\n      if (w.C === RED) {\r\n        w.C = BLACK\r\n        x.P.C = RED\r\n        rotateRight(tree, x.P)\r\n        w = x.P.L\r\n      }\r\n\r\n      if (w.R.C === BLACK && w.L.C === BLACK) {\r\n        w.C = RED\r\n        x = x.P\r\n      } else {\r\n        if (w.L.C === BLACK) {\r\n          w.R.C = BLACK\r\n          w.C = RED\r\n          rotateLeft(tree, w)\r\n          w = x.P.L\r\n        }\r\n\r\n        w.C = x.P.C\r\n        x.P.C = BLACK\r\n        w.L.C = BLACK\r\n        rotateRight(tree, x.P)\r\n        x = tree.root\r\n      }\r\n    }\r\n  }\r\n\r\n  x.C = BLACK\r\n}\r\n\r\nfunction minimumTree(x: TreeNode) {\r\n  while (x.L !== NULL_NODE) x = x.L\r\n  return x\r\n}\r\n\r\nfunction fixInsert(tree: Tree, z: TreeNode) {\r\n  let y: TreeNode\r\n  while (z.P.C === RED) {\r\n    if (z.P === z.P.P.L) {\r\n      y = z.P.P.R\r\n\r\n      if (y.C === RED) {\r\n        z.P.C = BLACK\r\n        y.C = BLACK\r\n        z.P.P.C = RED\r\n        z = z.P.P\r\n      } else {\r\n        if (z === z.P.R) {\r\n          z = z.P\r\n          rotateLeft(tree, z)\r\n        }\r\n\r\n        z.P.C = BLACK\r\n        z.P.P.C = RED\r\n        rotateRight(tree, z.P.P)\r\n      }\r\n    } else {\r\n      y = z.P.P.L\r\n\r\n      if (y.C === RED) {\r\n        z.P.C = BLACK\r\n        y.C = BLACK\r\n        z.P.P.C = RED\r\n        z = z.P.P\r\n      } else {\r\n        if (z === z.P.L) {\r\n          z = z.P\r\n          rotateRight(tree, z)\r\n        }\r\n\r\n        z.P.C = BLACK\r\n        z.P.P.C = RED\r\n        rotateLeft(tree, z.P.P)\r\n      }\r\n    }\r\n  }\r\n  tree.root.C = BLACK\r\n}\r\n\r\ninterface IIntervalTree {\r\n  insert(low: number, high: number, index: number): void\r\n  remove(index: number): void\r\n  search(\r\n    low: number,\r\n    high: number,\r\n    callback: (index: number, low: number) => any\r\n  ): void\r\n  size: number\r\n}\r\n\r\nexport function createIntervalTree(): IIntervalTree {\r\n  const tree = {\r\n    root: NULL_NODE,\r\n    size: 0,\r\n  }\r\n  // we know these indexes are a consistent, safe way to make look ups\r\n  // for our case so it's a solid O(1) alternative to\r\n  // the O(log n) searchNode() in typical interval trees\r\n  const indexMap: Record<number, TreeNode> = {}\r\n\r\n  return {\r\n    insert(low, high, index) {\r\n      let x: TreeNode = tree.root\r\n      let y: TreeNode = NULL_NODE\r\n\r\n      while (x !== NULL_NODE) {\r\n        y = x\r\n        if (low === y.low) break\r\n        if (low < x.low) x = x.L\r\n        else x = x.R\r\n      }\r\n\r\n      if (low === y.low && y !== NULL_NODE) {\r\n        if (!addInterval(y, high, index)) return\r\n        y.high = Math.max(y.high, high)\r\n        updateMax(y)\r\n        updateMaxUp(y)\r\n        indexMap[index] = y\r\n        tree.size++\r\n        return\r\n      }\r\n\r\n      const z: TreeNode = {\r\n        low,\r\n        high,\r\n        max: high,\r\n        C: RED,\r\n        P: y,\r\n        L: NULL_NODE,\r\n        R: NULL_NODE,\r\n        list: {index, high, next: null},\r\n      }\r\n\r\n      if (y === NULL_NODE) {\r\n        tree.root = z\r\n      } else {\r\n        if (z.low < y.low) y.L = z\r\n        else y.R = z\r\n        updateMaxUp(z)\r\n      }\r\n\r\n      fixInsert(tree, z)\r\n      indexMap[index] = z\r\n      tree.size++\r\n    },\r\n\r\n    remove(index) {\r\n      const z = indexMap[index]\r\n      if (z === void 0) return\r\n      delete indexMap[index]\r\n\r\n      const intervalResult = removeInterval(z, index)\r\n      if (intervalResult === void 0) return\r\n      if (intervalResult === KEEP) {\r\n        z.high = z.list.high\r\n        updateMax(z)\r\n        updateMaxUp(z)\r\n        tree.size--\r\n        return\r\n      }\r\n\r\n      let y = z\r\n      let originalYColor = y.C\r\n      let x: TreeNode\r\n\r\n      if (z.L === NULL_NODE) {\r\n        x = z.R\r\n        replaceNode(tree, z, z.R)\r\n      } else if (z.R === NULL_NODE) {\r\n        x = z.L\r\n        replaceNode(tree, z, z.L)\r\n      } else {\r\n        y = minimumTree(z.R)\r\n        originalYColor = y.C\r\n        x = y.R\r\n\r\n        if (y.P === z) {\r\n          x.P = y\r\n        } else {\r\n          replaceNode(tree, y, y.R)\r\n          y.R = z.R\r\n          y.R.P = y\r\n        }\r\n\r\n        replaceNode(tree, z, y)\r\n        y.L = z.L\r\n        y.L.P = y\r\n        y.C = z.C\r\n      }\r\n\r\n      updateMax(x)\r\n      updateMaxUp(x)\r\n\r\n      if (originalYColor === BLACK) fixRemove(tree, x)\r\n      tree.size--\r\n    },\r\n\r\n    search(low, high, callback) {\r\n      const stack = [tree.root]\r\n      while (stack.length !== 0) {\r\n        const node = stack.pop() as TreeNode\r\n        if (node === NULL_NODE || low > node.max) continue\r\n        if (node.L !== NULL_NODE) stack.push(node.L)\r\n        if (node.R !== NULL_NODE) stack.push(node.R)\r\n        if (node.low <= high && node.high >= low) {\r\n          let curr: ListNode | null = node.list\r\n          while (curr !== null) {\r\n            if (curr.high >= low) callback(curr.index, node.low)\r\n            curr = curr.next\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    get size() {\r\n      return tree.size\r\n    },\r\n  }\r\n}\r\n","import * as React from 'react'\r\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\r\nimport {createIntervalTree} from './interval-tree'\r\n\r\n/**\r\n * This hook creates the grid cell positioner and cache required by `useMasonry()`. This is\r\n * the meat of the grid's layout algorithm, determining which cells to render at a given scroll\r\n * position, as well as where to place new items in the grid.\r\n *\r\n * @param options Properties that determine the number of columns in the grid, as well\r\n *  as their widths.\r\n * @param deps This hook will create a new positioner, clearing all existing cached positions,\r\n *  whenever the dependencies in this list change.\r\n */\r\nexport function usePositioner(\r\n  {\r\n    width,\r\n    columnWidth = 200,\r\n    columnGutter = 0,\r\n    columnCount,\r\n  }: UsePositionerOptions,\r\n  deps: React.DependencyList = emptyArr\r\n): Positioner {\r\n  const initPositioner = (): Positioner => {\r\n    const [computedColumnWidth, computedColumnCount] = getColumns(\r\n      width,\r\n      columnWidth,\r\n      columnGutter,\r\n      columnCount\r\n    )\r\n    return createPositioner(\r\n      computedColumnCount,\r\n      computedColumnWidth,\r\n      columnGutter\r\n    )\r\n  }\r\n  const [positioner, setPositioner] = React.useState<Positioner>(initPositioner)\r\n  const didMount = React.useRef(0)\r\n\r\n  // Create a new positioner when the dependencies change\r\n  useLayoutEffect(() => {\r\n    if (didMount.current) setPositioner(initPositioner())\r\n    didMount.current = 1\r\n    // eslint-disable-next-line\r\n  }, deps)\r\n\r\n  // Updates the item positions any time a prop potentially affecting their\r\n  // size changes\r\n  useLayoutEffect(() => {\r\n    if (didMount.current) {\r\n      const cacheSize = positioner.size()\r\n      const nextPositioner = initPositioner()\r\n      let index = 0\r\n\r\n      for (; index < cacheSize; index++) {\r\n        const pos = positioner.get(index)\r\n        nextPositioner.set(index, pos !== void 0 ? pos.height : 0)\r\n      }\r\n\r\n      setPositioner(nextPositioner)\r\n    }\r\n    // eslint-disable-next-line\r\n  }, [width, columnWidth, columnGutter, columnCount])\r\n\r\n  return positioner\r\n}\r\n\r\nexport interface UsePositionerOptions {\r\n  /**\r\n   * The width of the container you're rendering the grid within, i.e. the container\r\n   * element's `element.offsetWidth`\r\n   */\r\n  width: number\r\n  /**\r\n   * The minimum column width. The `usePositioner()` hook will automatically size the\r\n   * columns to fill their container based upon the `columnWidth` and `columnGutter` values.\r\n   * It will never render anything smaller than this width unless its container itself is\r\n   * smaller than its value. This property is optional if you're using a static `columnCount`.\r\n   * @default 200\r\n   */\r\n  columnWidth?: number\r\n  /**\r\n   * This sets the vertical and horizontal space between grid cells in pixels.\r\n   */\r\n  columnGutter?: number\r\n  /**\r\n   * By default, `usePositioner()` derives the column count from the `columnWidth`, `columnGutter`,\r\n   * and `width` props. However, in some situations it is nice to be able to override that behavior\r\n   * (e.g. creating a `List` component).\r\n   */\r\n  columnCount?: number\r\n}\r\n\r\n/**\r\n * Creates a cell positioner for the `useMasonry()` hook. The `usePositioner()` hook uses\r\n * this utility under the hood.\r\n *\r\n * @param columnCount The number of columns in the grid\r\n * @param columnWidth The width of each column in the grid\r\n * @param columnGutter The amount of horizontal and vertical space in pixels to render\r\n *  between each grid item.\r\n */\r\nexport const createPositioner = (\r\n  columnCount: number,\r\n  columnWidth: number,\r\n  columnGutter = 0\r\n): Positioner => {\r\n  // O(log(n)) lookup of cells to render for a given viewport size\r\n  // Store tops and bottoms of each cell for fast intersection lookup.\r\n  const intervalTree = createIntervalTree()\r\n  // Track the height of each column.\r\n  // Layout algorithm below always inserts into the shortest column.\r\n  const columnHeights: number[] = new Array(columnCount)\r\n  // Used for O(1) item access\r\n  const items: PositionerItem[] = []\r\n  // Tracks the item indexes within an individual column\r\n  const columnItems: number[][] = new Array(columnCount)\r\n\r\n  for (let i = 0; i < columnCount; i++) {\r\n    columnHeights[i] = 0\r\n    columnItems[i] = []\r\n  }\r\n\r\n  return {\r\n    columnCount,\r\n    columnWidth,\r\n    set: (index, height = 0) => {\r\n      let column = 0\r\n\r\n      // finds the shortest column and uses it\r\n      for (let i = 1; i < columnHeights.length; i++) {\r\n        if (columnHeights[i] < columnHeights[column]) column = i\r\n      }\r\n\r\n      const top = columnHeights[column] || 0\r\n      columnHeights[column] = top + height + columnGutter\r\n      columnItems[column].push(index)\r\n      items[index] = {\r\n        left: column * (columnWidth + columnGutter),\r\n        top,\r\n        height,\r\n        column,\r\n      }\r\n      intervalTree.insert(top, top + height, index)\r\n    },\r\n    get: (index) => items[index],\r\n    // This only updates items in the specific columns that have changed, on and after the\r\n    // specific items that have changed\r\n    update: (updates) => {\r\n      const columns: number[] = new Array(columnCount)\r\n      let i = 0,\r\n        j = 0\r\n\r\n      // determines which columns have items that changed, as well as the minimum index\r\n      // changed in that column, as all items after that index will have their positions\r\n      // affected by the change\r\n      for (; i < updates.length - 1; i++) {\r\n        const index = updates[i]\r\n        const item = items[index]\r\n        item.height = updates[++i]\r\n        intervalTree.remove(index)\r\n        intervalTree.insert(item.top, item.top + item.height, index)\r\n        columns[item.column] =\r\n          columns[item.column] === void 0\r\n            ? index\r\n            : Math.min(index, columns[item.column])\r\n      }\r\n\r\n      for (i = 0; i < columns.length; i++) {\r\n        // bails out if the column didn't change\r\n        if (columns[i] === void 0) continue\r\n        const itemsInColumn = columnItems[i]\r\n        // the index order is sorted with certainty so binary search is a great solution\r\n        // here as opposed to Array.indexOf()\r\n        const startIndex = binarySearch(itemsInColumn, columns[i])\r\n        const index = columnItems[i][startIndex]\r\n        const startItem = items[index]\r\n        columnHeights[i] = startItem.top + startItem.height + columnGutter\r\n\r\n        for (j = startIndex + 1; j < itemsInColumn.length; j++) {\r\n          const index = itemsInColumn[j]\r\n          const item = items[index]\r\n          item.top = columnHeights[i]\r\n          columnHeights[i] = item.top + item.height + columnGutter\r\n          intervalTree.remove(index)\r\n          intervalTree.insert(item.top, item.top + item.height, index)\r\n        }\r\n      }\r\n    },\r\n    // Render all cells visible within the viewport range defined.\r\n    range: (lo, hi, renderCallback) =>\r\n      intervalTree.search(lo, hi, (index, top) =>\r\n        renderCallback(index, items[index].left, top)\r\n      ),\r\n    estimateHeight: (itemCount, defaultItemHeight): number => {\r\n      const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights))\r\n\r\n      return itemCount === intervalTree.size\r\n        ? tallestColumn\r\n        : tallestColumn +\r\n            Math.ceil((itemCount - intervalTree.size) / columnCount) *\r\n              defaultItemHeight\r\n    },\r\n    shortestColumn: () => {\r\n      if (columnHeights.length > 1) return Math.min.apply(null, columnHeights)\r\n      return columnHeights[0] || 0\r\n    },\r\n    size(): number {\r\n      return intervalTree.size\r\n    },\r\n  }\r\n}\r\n\r\nexport interface Positioner {\r\n  /**\r\n   * The number of columns in the grid\r\n   */\r\n  columnCount: number\r\n  /**\r\n   * The width of each column in the grid\r\n   */\r\n  columnWidth: number\r\n  /**\r\n   * Sets the position for the cell at `index` based upon the cell's height\r\n   */\r\n  set: (index: number, height: number) => void\r\n  /**\r\n   * Gets the `PositionerItem` for the cell at `index`\r\n   */\r\n  get: (index: number) => PositionerItem | undefined\r\n  /**\r\n   * Updates cells based on their indexes and heights\r\n   * positioner.update([index, height, index, height, index, height...])\r\n   */\r\n  update: (updates: number[]) => void\r\n  /**\r\n   * Searches the interval tree for grid cells with a `top` value in\r\n   * betwen `lo` and `hi` and invokes the callback for each item that\r\n   * is discovered\r\n   */\r\n  range: (\r\n    lo: number,\r\n    hi: number,\r\n    renderCallback: (index: number, left: number, top: number) => void\r\n  ) => void\r\n  /**\r\n   * Returns the number of grid cells in the cache\r\n   */\r\n\r\n  size: () => number\r\n  /**\r\n   * Estimates the total height of the grid\r\n   */\r\n\r\n  estimateHeight: (itemCount: number, defaultItemHeight: number) => number\r\n  /**\r\n   * Returns the height of the shortest column in the grid\r\n   */\r\n\r\n  shortestColumn: () => number\r\n}\r\n\r\nexport interface PositionerItem {\r\n  /**\r\n   * This is how far from the top edge of the grid container in pixels the\r\n   * item is placed\r\n   */\r\n  top: number\r\n  /**\r\n   * This is how far from the left edge of the grid container in pixels the\r\n   * item is placed\r\n   */\r\n  left: number\r\n  /**\r\n   * This is the height of the grid cell\r\n   */\r\n  height: number\r\n  /**\r\n   * This is the column number containing the grid cell\r\n   */\r\n  column: number\r\n}\r\n\r\n/* istanbul ignore next */\r\nconst binarySearch = (a: number[], y: number): number => {\r\n  let l = 0\r\n  let h = a.length - 1\r\n\r\n  while (l <= h) {\r\n    const m = (l + h) >>> 1\r\n    const x = a[m]\r\n    if (x === y) return m\r\n    else if (x <= y) l = m + 1\r\n    else h = m - 1\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\nconst getColumns = (\r\n  width = 0,\r\n  minimumWidth = 0,\r\n  gutter = 8,\r\n  columnCount?: number\r\n): [number, number] => {\r\n  columnCount = columnCount || Math.floor(width / (minimumWidth + gutter)) || 1\r\n  const columnWidth = Math.floor(\r\n    (width - gutter * (columnCount - 1)) / columnCount\r\n  )\r\n  return [columnWidth, columnCount]\r\n}\r\n\r\nconst emptyArr: [] = []\r\n","import * as React from 'react'\r\nimport useLatest from '@react-hook/latest'\r\nimport useEvent from '@react-hook/event'\r\nimport {useThrottleCallback} from '@react-hook/throttle'\r\nimport type {Positioner, PositionerItem} from './use-positioner'\r\n\r\n/**\r\n * A hook that creates a callback for scrolling to a specific index in\r\n * the \"items\" array.\r\n *\r\n * @param positioner A positioner created by the `usePositioner()` hook\r\n * @param options Configuration options\r\n */\r\nexport function useScrollToIndex(\r\n  positioner: Positioner,\r\n  options: UseScrollToIndexOptions\r\n) {\r\n  const {\r\n    align = 'top',\r\n    element = typeof window !== 'undefined' && window,\r\n    offset = 0,\r\n    height = typeof window !== 'undefined' ? window.innerHeight : 0,\r\n  } = options\r\n  const latestOptions = useLatest({\r\n    positioner,\r\n    element,\r\n    align,\r\n    offset,\r\n    height,\r\n  } as const)\r\n  const getTarget = React.useRef(() => {\r\n    const latestElement = latestOptions.current.element\r\n    return latestElement && 'current' in latestElement\r\n      ? latestElement.current\r\n      : latestElement\r\n  }).current\r\n  const [state, dispatch] = React.useReducer(\r\n    (\r\n      state: {\r\n        position: PositionerItem | undefined\r\n        index: number | undefined\r\n        prevTop: number | undefined\r\n      },\r\n      action:\r\n        | {type: 'scrollToIndex'; value: number | undefined}\r\n        | {type: 'setPosition'; value: PositionerItem | undefined}\r\n        | {type: 'setPrevTop'; value: number | undefined}\r\n        | {type: 'reset'}\r\n    ) => {\r\n      const nextState = {\r\n        position: state.position,\r\n        index: state.index,\r\n        prevTop: state.prevTop,\r\n      }\r\n\r\n      /* istanbul ignore next */\r\n      if (action.type === 'scrollToIndex') {\r\n        return {\r\n          position: latestOptions.current.positioner.get(action.value ?? -1),\r\n          index: action.value,\r\n          prevTop: void 0,\r\n        }\r\n      } else if (action.type === 'setPosition') {\r\n        nextState.position = action.value\r\n      } else if (action.type === 'setPrevTop') {\r\n        nextState.prevTop = action.value\r\n      } else if (action.type === 'reset') {\r\n        return defaultState\r\n      }\r\n\r\n      return nextState\r\n    },\r\n    defaultState\r\n  )\r\n  const throttledDispatch = useThrottleCallback(dispatch, 15)\r\n\r\n  // If we find the position along the way we can immediately take off\r\n  // to the correct spot.\r\n  useEvent(getTarget() as Window, 'scroll', () => {\r\n    if (!state.position && state.index) {\r\n      const position = latestOptions.current.positioner.get(state.index)\r\n\r\n      if (position) {\r\n        dispatch({type: 'setPosition', value: position})\r\n      }\r\n    }\r\n  })\r\n\r\n  // If the top changes out from under us in the case of dynamic cells, we\r\n  // want to keep following it.\r\n  const currentTop =\r\n    state.index !== void 0 &&\r\n    latestOptions.current.positioner.get(state.index)?.top\r\n\r\n  React.useEffect(() => {\r\n    const target = getTarget()\r\n    if (!target) return\r\n    const {height, align, offset, positioner} = latestOptions.current\r\n\r\n    if (state.position) {\r\n      let scrollTop = state.position.top\r\n\r\n      if (align === 'bottom') {\r\n        scrollTop = scrollTop - height + state.position.height\r\n      } else if (align === 'center') {\r\n        scrollTop -= (height - state.position.height) / 2\r\n      }\r\n\r\n      target.scrollTo(0, Math.max(0, (scrollTop += offset)))\r\n      // Resets state after 400ms, an arbitrary time I determined to be\r\n      // still visually pleasing if there is a slow network reply in dynamic\r\n      // cells\r\n      let didUnsubscribe = false\r\n      const timeout = setTimeout(\r\n        () => !didUnsubscribe && dispatch({type: 'reset'}),\r\n        400\r\n      )\r\n      return () => {\r\n        didUnsubscribe = true\r\n        clearTimeout(timeout)\r\n      }\r\n    } else if (state.index !== void 0) {\r\n      // Estimates the top based upon the average height of current cells\r\n      let estimatedTop =\r\n        (positioner.shortestColumn() / positioner.size()) * state.index\r\n      if (state.prevTop)\r\n        estimatedTop = Math.max(estimatedTop, state.prevTop + height)\r\n      target.scrollTo(0, estimatedTop)\r\n      throttledDispatch({type: 'setPrevTop', value: estimatedTop})\r\n    }\r\n  }, [currentTop, state, latestOptions, getTarget, throttledDispatch])\r\n\r\n  return React.useRef((index: number) => {\r\n    dispatch({type: 'scrollToIndex', value: index})\r\n  }).current\r\n}\r\n\r\nconst defaultState = {\r\n  index: void 0,\r\n  position: void 0,\r\n  prevTop: void 0,\r\n} as const\r\n\r\nexport type UseScrollToIndexOptions = {\r\n  /**\r\n   * The window element or a React ref for the window element. That is,\r\n   * this is the grid container.\r\n   * @default window\r\n   */\r\n  element?: Window | HTMLElement | React.RefObject<HTMLElement> | null\r\n  /**\r\n   * Sets the vertical alignment of the cell within the grid container.\r\n   * @default \"top\"\r\n   */\r\n  align?: 'center' | 'top' | 'bottom'\r\n  /**\r\n   * The height of the grid.\r\n   * @default window.innerHeight\r\n   */\r\n  height?: number\r\n  /**\r\n   * The vertical space in pixels between the top of the grid container and the top\r\n   * of the window.\r\n   * @default 0\r\n   */\r\n  offset?: number\r\n}\r\n","import * as React from 'react'\r\nimport {useWindowSize} from '@react-hook/window-size'\r\nimport {MasonryScroller} from './masonry-scroller'\r\nimport type {MasonryScrollerProps} from './masonry-scroller'\r\nimport {useContainerPosition} from './use-container-position'\r\nimport {useResizeObserver} from './use-resize-observer'\r\nimport {usePositioner} from './use-positioner'\r\nimport type {UsePositionerOptions} from './use-positioner'\r\nimport {useScrollToIndex} from './use-scroll-to-index'\r\nimport type {UseScrollToIndexOptions} from './use-scroll-to-index'\r\n\r\n/**\r\n * A \"batteries included\" masonry grid which includes all of the implementation details below. This component is the\r\n * easiest way to get off and running in your app, before switching to more advanced implementations, if necessary.\r\n * It will change its column count to fit its container's width and will decide how many rows to render based upon\r\n * the height of the browser `window`.\r\n */\r\nexport function Masonry<Item>(props: MasonryProps<Item>) {\r\n  const containerRef = React.useRef<null | HTMLElement>(null)\r\n  const windowSize = useWindowSize({\r\n    initialWidth: props.ssrWidth,\r\n    initialHeight: props.ssrHeight,\r\n  })\r\n  const containerPos = useContainerPosition(containerRef, windowSize)\r\n  const nextProps = Object.assign(\r\n    {\r\n      offset: containerPos.offset,\r\n      width: containerPos.width || windowSize[0],\r\n      height: windowSize[1],\r\n      containerRef,\r\n    },\r\n    props\r\n  ) as any\r\n  nextProps.positioner = usePositioner(nextProps)\r\n  nextProps.resizeObserver = useResizeObserver(nextProps.positioner)\r\n  const scrollToIndex = useScrollToIndex(nextProps.positioner, {\r\n    height: nextProps.height,\r\n    offset: containerPos.offset,\r\n    align:\r\n      typeof props.scrollToIndex === 'object'\r\n        ? props.scrollToIndex.align\r\n        : void 0,\r\n  })\r\n  const index =\r\n    props.scrollToIndex &&\r\n    (typeof props.scrollToIndex === 'number'\r\n      ? props.scrollToIndex\r\n      : props.scrollToIndex.index)\r\n\r\n  React.useEffect(() => {\r\n    if (index !== void 0) scrollToIndex(index)\r\n  }, [index, scrollToIndex])\r\n\r\n  return React.createElement(MasonryScroller, nextProps)\r\n}\r\n\r\nexport interface MasonryProps<Item>\r\n  extends Omit<\r\n      MasonryScrollerProps<Item>,\r\n      'offset' | 'width' | 'height' | 'containerRef' | 'positioner'\r\n    >,\r\n    Pick<UsePositionerOptions, 'columnWidth' | 'columnGutter' | 'columnCount'> {\r\n  /**\r\n   * Scrolls to a given index within the grid. The grid will re-scroll\r\n   * any time the index changes.\r\n   */\r\n  scrollToIndex?:\r\n    | number\r\n    | {\r\n        index: number\r\n        align: UseScrollToIndexOptions['align']\r\n      }\r\n  /**\r\n   * This is the width that will be used for the browser `window` when rendering this component in SSR.\r\n   * This prop isn't relevant for client-side only apps.\r\n   */\r\n  ssrWidth?: number\r\n  /**\r\n   * This is the height that will be used for the browser `window` when rendering this component in SSR.\r\n   * This prop isn't relevant for client-side only apps.\r\n   */\r\n  ssrHeight?: number\r\n  /**\r\n   * This determines how often (in frames per second) to update the scroll position of the\r\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\r\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\r\n   * heavy `render` components it may be prudent to reduce this number.\r\n   * @default 12\r\n   */\r\n  scrollFps?: number\r\n}\r\n\r\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\r\n  Masonry.displayName = 'Masonry'\r\n}\r\n","import * as React from 'react'\r\nimport {Masonry} from './masonry'\r\nimport type {MasonryProps} from './masonry'\r\n\r\n/**\r\n * This is just a single-column `<Masonry>` component with `rowGutter` prop instead of\r\n * a `columnGutter` prop.\r\n */\r\nexport function List<Item>(props: ListProps<Item>) {\r\n  return (\r\n    <Masonry<Item>\r\n      role='list'\r\n      columnGutter={props.rowGutter}\r\n      columnCount={1}\r\n      columnWidth={1}\r\n      {...props}\r\n    />\r\n  )\r\n}\r\n\r\nexport interface ListProps<Item>\r\n  extends Omit<\r\n    MasonryProps<Item>,\r\n    'columGutter' | 'columnCount' | 'columnWidth'\r\n  > {\r\n  /**\r\n   * The amount of vertical space in pixels to add between the list cells.\r\n   * @default 0\r\n   */\r\n  rowGutter?: number\r\n}\r\n\r\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\r\n  List.displayName = 'List'\r\n}\r\n","import * as React from 'react'\r\nimport useLatest from '@react-hook/latest'\r\n\r\n/**\r\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\r\n * hook invokes a callback each time the last rendered index surpasses the total number of items\r\n * in your items array or the number defined in the `totalItems` option.\r\n *\r\n * @param loadMoreItems This callback is invoked when more rows must be loaded. It will be used to\r\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\r\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\r\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\r\n *  as well.\r\n * @param options\r\n */\r\nexport function useInfiniteLoader<Item, T extends LoadMoreItemsCallback<Item>>(\r\n  loadMoreItems: T,\r\n  options: UseInfiniteLoaderOptions<Item> = emptyObj\r\n): LoadMoreItemsCallback<Item> {\r\n  const {\r\n    isItemLoaded,\r\n    minimumBatchSize = 16,\r\n    threshold = 16,\r\n    totalItems = 9e9,\r\n  } = options\r\n  const storedLoadMoreItems = useLatest(loadMoreItems)\r\n  const storedIsItemLoaded = useLatest(isItemLoaded)\r\n\r\n  return React.useCallback(\r\n    (startIndex, stopIndex, items) => {\r\n      const unloadedRanges = scanForUnloadedRanges(\r\n        storedIsItemLoaded.current,\r\n        minimumBatchSize,\r\n        items,\r\n        totalItems,\r\n        Math.max(0, startIndex - threshold),\r\n        Math.min(totalItems - 1, (stopIndex || 0) + threshold)\r\n      )\r\n      // The user is responsible for memoizing their loadMoreItems() function\r\n      // because we don't want to make assumptions about how they want to deal\r\n      // with `items`\r\n      for (let i = 0; i < unloadedRanges.length - 1; ++i)\r\n        storedLoadMoreItems.current(\r\n          unloadedRanges[i],\r\n          unloadedRanges[++i],\r\n          items\r\n        )\r\n    },\r\n    [\r\n      totalItems,\r\n      minimumBatchSize,\r\n      threshold,\r\n      storedLoadMoreItems,\r\n      storedIsItemLoaded,\r\n    ]\r\n  )\r\n}\r\n\r\n/**\r\n * Returns all of the ranges within a larger range that contain unloaded rows.\r\n */\r\nfunction scanForUnloadedRanges<Item>(\r\n  isItemLoaded: UseInfiniteLoaderOptions<\r\n    Item\r\n  >['isItemLoaded'] = defaultIsItemLoaded,\r\n  minimumBatchSize: UseInfiniteLoaderOptions<Item>['minimumBatchSize'] = 16,\r\n  items: any[],\r\n  totalItems: UseInfiniteLoaderOptions<Item>['totalItems'] = 9e9,\r\n  startIndex: number,\r\n  stopIndex: number\r\n): number[] {\r\n  const unloadedRanges: number[] = []\r\n  let rangeStartIndex: number | undefined,\r\n    rangeStopIndex: number | undefined,\r\n    index = startIndex\r\n\r\n  /* istanbul ignore next */\r\n  for (; index <= stopIndex; index++) {\r\n    if (!isItemLoaded(index, items)) {\r\n      rangeStopIndex = index\r\n      if (rangeStartIndex === void 0) rangeStartIndex = index\r\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\r\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex)\r\n      rangeStartIndex = rangeStopIndex = void 0\r\n    }\r\n  }\r\n\r\n  // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\r\n  // Scan forward to try filling our :minimumBatchSize.\r\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\r\n    const potentialStopIndex = Math.min(\r\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\r\n      totalItems - 1\r\n    )\r\n\r\n    /* istanbul ignore next */\r\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\r\n      if (!isItemLoaded(index, items)) {\r\n        rangeStopIndex = index\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n\r\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex)\r\n  }\r\n\r\n  // Check to see if our first range ended prematurely.\r\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\r\n  /* istanbul ignore next */\r\n  if (unloadedRanges.length) {\r\n    let firstUnloadedStart = unloadedRanges[0]\r\n    const firstUnloadedStop = unloadedRanges[1]\r\n\r\n    while (\r\n      firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize &&\r\n      firstUnloadedStart > 0\r\n    ) {\r\n      const index = firstUnloadedStart - 1\r\n\r\n      if (!isItemLoaded(index, items)) {\r\n        unloadedRanges[0] = firstUnloadedStart = index\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  return unloadedRanges\r\n}\r\n\r\nconst defaultIsItemLoaded = <Item>(index: number, items: Item[]): boolean =>\r\n  items[index] !== void 0\r\n\r\nexport interface UseInfiniteLoaderOptions<Item> {\r\n  /**\r\n   *  A callback responsible for determining the loaded state of each item. Should return `true`\r\n   * if the item has already been loaded and `false` if not.\r\n   * @default (index: number, items: any[]) => boolean\r\n   */\r\n  isItemLoaded?: (index: number, items: Item[]) => boolean\r\n  /**\r\n   * The minimum number of new items to be loaded at a time.  This property can be used to\r\n   * batch requests and reduce HTTP requests.\r\n   * @default 16\r\n   */\r\n  minimumBatchSize?: number\r\n  /**\r\n   * The threshold at which to pre-fetch data. A threshold X means that new data should start\r\n   * loading when a user scrolls within X cells of the end of your `items` array.\r\n   * @default 16\r\n   */\r\n  threshold?: number\r\n  /**\r\n   * The total number of items you'll need to eventually load (if known). This can\r\n   * be arbitrarily high if not known.\r\n   * @default 9e9\r\n   */\r\n  totalItems?: number\r\n}\r\n\r\nexport type LoadMoreItemsCallback<Item> = (\r\n  startIndex: number,\r\n  stopIndex: number,\r\n  items: Item[]\r\n) => any\r\n\r\nconst emptyObj = {}\r\n","export const elementsCache: WeakMap<Element, number> = new Map()\r\n"],"names":["useScroller","offset","fps","setIsScrolling","scrollTop","useScrollPosition","isScrolling","React","didMount","current","to","requestTimeout","clearRequestTimeout","Math","max","useForceUpdate","setState","emptyObj","useMasonry","positioner","resizeObserver","items","as","ContainerComponent","id","className","style","role","tabIndex","containerRef","itemAs","ItemComponent","itemStyle","itemHeightEstimate","itemKey","defaultGetItemKey","overscanBy","height","render","RenderComponent","onRender","startIndex","stopIndex","forceUpdate","setItemRef","getRefSetter","itemCount","length","columnWidth","columnCount","range","estimateHeight","size","shortestColumn","measuredCount","shortestColumnSize","children","itemRole","storedOnRender","useLatest","rangeEnd","needsFreshBatch","index","left","top","data","key","phaseTwoStyle","width","writingMode","position","push","__reactCreateElement__","ref","Object","assign","createRenderElement","min","batchSize","ceil","phaseOneStyle","getCachedSize","didEverMount","containerStyle","getContainerStyle","assignUserStyle","_","i","MasonryScroller","props","scrollFps","useContainerPosition","elementRef","deps","emptyArr","containerPosition","setContainerPosition","useLayoutEffect","el","offsetTop","offsetParent","offsetWidth","useResizeObserver","disconnect","createResizeObserver","updateMax","node","high","L","NULL_NODE","R","updateMaxUp","x","P","rotateLeft","tree","y","root","rotateRight","replaceNode","usePositioner","columnGutter","initPositioner","computedColumnWidth","computedColumnCount","getColumns","createPositioner","setPositioner","cacheSize","nextPositioner","pos","get","set","useScrollToIndex","options","align","element","window","innerHeight","latestOptions","getTarget","latestElement","state","dispatch","action","nextState","prevTop","type","value","defaultState","throttledDispatch","useThrottleCallback","useEvent","currentTop","_latestOptions$curren","target","scrollTo","didUnsubscribe","timeout","setTimeout","clearTimeout","estimatedTop","Masonry","windowSize","useWindowSize","initialWidth","ssrWidth","initialHeight","ssrHeight","containerPos","nextProps","scrollToIndex","List","rowGutter","useInfiniteLoader","loadMoreItems","isItemLoaded","minimumBatchSize","threshold","totalItems","storedLoadMoreItems","storedIsItemLoaded","unloadedRanges","defaultIsItemLoaded","rangeStartIndex","rangeStopIndex","potentialStopIndex","firstUnloadedStart","firstUnloadedStop","scanForUnloadedRanges","elementsCache","Map","trieMemoize","OneKeyMap","WeakMap","memoizeOne","maxWidth","maxHeight","willChange","pointerEvents","cmp2","args","pargs","userStyle","zIndex","visibility","observe","offsetHeight","updater","ResizeObserver","entries","updates","entry","update","low","C","undefined","list","intervalTree","indexMap","insert","treeNode","prevNode","next","addInterval","z","fixInsert","remove","intervalResult","removeInterval","originalYColor","minimumTree","w","fixRemove","search","callback","stack","pop","curr","createIntervalTree","columnHeights","Array","columnItems","column","columns","j","item","itemsInColumn","binarySearch","startItem","lo","hi","renderCallback","defaultItemHeight","tallestColumn","apply","a","l","h","m","minimumWidth","gutter","floor"],"mappings":"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"}