{"version":3,"file":"masonic.js","sources":["../../node_modules/@react-hook/event/src/index.tsx","../../node_modules/@react-hook/throttle/src/index.tsx","../../src/use-scroller.ts","../../node_modules/@react-hook/window-scroll/src/index.tsx","../../node_modules/@essentials/request-timeout/src/index.ts","../../src/use-force-update.ts","../../src/use-masonry.tsx","../../src/masonry-scroller.tsx","../../src/use-container-position.ts","../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","../../src/use-resize-observer.ts","../../src/interval-tree.ts","../../src/use-positioner.ts","../../src/use-scroll-to-index.ts","../../src/masonry.tsx","../../node_modules/@react-hook/window-size/src/index.tsx","../../node_modules/@react-hook/debounce/src/index.tsx","../../node_modules/@react-hook/latest/src/index.tsx","../../node_modules/@react-hook/passive-layout-effect/src/index.tsx","../../node_modules/@essentials/raf/src/index.ts","../../node_modules/trie-memoize/src/index.ts","../../node_modules/@essentials/one-key-map/src/index.ts","../../node_modules/@essentials/memoize-one/src/index.ts","../../src/elements-cache.ts","../../src/use-infinite-loader.ts","../../src/list.tsx"],"sourcesContent":["import * as React from 'react'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\nimport useLatest from '@react-hook/latest'\n\nfunction useEvent<\n  T extends Window = Window,\n  K extends keyof WindowEventMap = keyof WindowEventMap\n>(\n  target: Window | null,\n  type: K,\n  listener: WindowEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends Document = Document,\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n>(\n  target: Document | null,\n  type: K,\n  listener: DocumentEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends HTMLElement = HTMLElement,\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n>(\n  target: React.RefObject<T> | T | null,\n  type: K,\n  listener: ElementEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent(target: any, type: any, listener: any, cleanup: any): void {\n  const storedListener = useLatest(listener)\n  const storedCleanup = useLatest(cleanup)\n\n  useLayoutEffect(() => {\n    const targetEl = target && 'current' in target ? target.current : target\n    if (!targetEl) return\n\n    let didUnsubscribe = 0\n    function listener(this: any, ...args: any[]) {\n      if (didUnsubscribe) return\n      storedListener.current.apply(this, args)\n    }\n\n    targetEl.addEventListener(type, listener)\n    const cleanup = storedCleanup.current\n\n    return () => {\n      didUnsubscribe = 1\n      targetEl.removeEventListener(type, listener)\n      cleanup && cleanup()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, type])\n}\n\nexport type ElementEventListener<\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n> = (this: HTMLElement, ev: HTMLElementEventMap[K]) => any\n\nexport type DocumentEventListener<\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n> = (this: Document, ev: DocumentEventMap[K]) => any\n\nexport type WindowEventListener<\n  K extends keyof WindowEventMap = keyof WindowEventMap\n> = (this: Document, ev: WindowEventMap[K]) => any\n\nexport default useEvent\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\nconst perf = typeof performance !== 'undefined' ? performance : Date\nconst now = () => perf.now()\n\nexport function useThrottleCallback<CallbackArguments extends any[]>(\n  callback: (...args: CallbackArguments) => void,\n  fps = 30,\n  leading = false\n): (...args: CallbackArguments) => void {\n  const storedCallback = useLatest(callback)\n  const ms = 1000 / fps\n  const prev = React.useRef(0)\n  const trailingTimeout = React.useRef<ReturnType<typeof setTimeout>>()\n  const clearTrailing = () =>\n    trailingTimeout.current && clearTimeout(trailingTimeout.current)\n  const deps = [fps, leading, storedCallback]\n\n  // Reset any time the deps change\n  React.useEffect(\n    () => () => {\n      prev.current = 0\n      clearTrailing()\n    },\n    deps\n  )\n\n  return React.useCallback(function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args = arguments\n    const rightNow = now()\n    const call = () => {\n      prev.current = rightNow\n      clearTrailing()\n      storedCallback.current.apply(null, args as any)\n    }\n    const current = prev.current\n    // leading\n    if (leading && current === 0) return call()\n    // body\n    if (rightNow - current > ms) {\n      if (current > 0) return call()\n      prev.current = rightNow\n    }\n    // trailing\n    clearTrailing()\n    trailingTimeout.current = setTimeout(() => {\n      call()\n      prev.current = 0\n    }, ms)\n  }, deps)\n}\n\nexport function useThrottle<State>(\n  initialState: State | (() => State),\n  fps?: number,\n  leading?: boolean\n): [State, React.Dispatch<React.SetStateAction<State>>] {\n  const state = React.useState<State>(initialState)\n  return [state[0], useThrottleCallback(state[1], fps, leading)]\n}\n","import * as React from 'react'\r\nimport useScrollPosition from '@react-hook/window-scroll'\r\nimport {requestTimeout, clearRequestTimeout} from '@essentials/request-timeout'\r\n\r\n/**\r\n * A hook for tracking whether the `window` is currently being scrolled and it's scroll position on\r\n * the y-axis. These values are used for determining which grid cells to render and when\r\n * to add styles to the masonry container that maximize scroll performance.\r\n *\r\n * @param offset The vertical space in pixels between the top of the grid container and the top\r\n *  of the browser `document.documentElement`.\r\n * @param fps This determines how often (in frames per second) to update the scroll position of the\r\n *  browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\r\n *  The default value of `12` has been very reasonable in my own testing, but if you have particularly\r\n *  heavy `render` components it may be prudent to reduce this number.\r\n */\r\nexport function useScroller(\r\n  offset = 0,\r\n  fps = 12\r\n): {scrollTop: number; isScrolling: boolean} {\r\n  const scrollTop = useScrollPosition(fps)\r\n  const [isScrolling, setIsScrolling] = React.useState(false)\r\n  const didMount = React.useRef(0)\r\n\r\n  React.useEffect(() => {\r\n    if (didMount.current === 1) setIsScrolling(true)\r\n    const to = requestTimeout(() => {\r\n      // This is here to prevent premature bail outs while maintaining high resolution\r\n      // unsets. Without it there will always bee a lot of unnecessary DOM writes to style.\r\n      setIsScrolling(false)\r\n    }, 40 + 1000 / fps)\r\n    didMount.current = 1\r\n    return () => clearRequestTimeout(to)\r\n  }, [fps, scrollTop])\r\n\r\n  return {scrollTop: Math.max(0, scrollTop - offset), isScrolling}\r\n}\r\n","import {useThrottle} from '@react-hook/throttle'\nimport useEvent from '@react-hook/event'\n\nconst win = typeof window === 'undefined' ? null : window\nconst getScrollY = (): number =>\n  (win as Window).scrollY !== void 0\n    ? (win as Window).scrollY\n    : (win as Window).pageYOffset === void 0\n    ? 0\n    : (win as Window).pageYOffset\n\nexport const useWindowScroll = (fps = 30): number => {\n  const state = useThrottle(\n    typeof window === 'undefined' ? 0 : getScrollY,\n    fps,\n    true\n  )\n  useEvent(win, 'scroll', (): void => state[1](getScrollY()))\n  return state[0]\n}\n\nexport default useWindowScroll\n","/**\n * Copyright 2011, Joe Lambert.\n * Free to use under the MIT license.\n * http://www.opensource.org/licenses/mit-license.php\n **/\nimport {raf, caf, now} from '@essentials/raf'\n\nexport interface RequestTimeoutHandle {\n  v?: number\n}\n\nexport const clearRequestTimeout = (handle: RequestTimeoutHandle): void => {\n  caf(handle.v || -1)\n}\n\nexport const requestTimeout = (\n  fn: (...args: any[]) => void,\n  ms: number\n): RequestTimeoutHandle => {\n  const start = now(),\n    handle: RequestTimeoutHandle = {}\n\n  const loop = () => {\n    now() - start >= ms ? fn.call(null) : (handle.v = raf(loop))\n  }\n\n  handle.v = raf(loop)\n  return handle\n}\n\nexport default requestTimeout\n","import * as React from 'react'\r\n\r\nexport function useForceUpdate() {\r\n  const setState = React.useState(emptyObj)[1]\r\n  return React.useRef(() => setState({})).current\r\n}\r\n\r\nconst emptyObj = {}\r\n","import * as React from 'react'\r\nimport trieMemoize from 'trie-memoize'\r\nimport OneKeyMap from '@essentials/one-key-map'\r\nimport memoizeOne from '@essentials/memoize-one'\r\nimport useLatest from '@react-hook/latest'\r\nimport {elementsCache} from './elements-cache'\r\nimport {useForceUpdate} from './use-force-update'\r\nimport type {Positioner} from './use-positioner'\r\n\r\n/**\r\n * This hook handles the render phases of the masonry layout and returns the grid as a React element.\r\n *\r\n * @param options Options for configuring the masonry layout renderer. See `UseMasonryOptions`.\r\n */\r\nexport function useMasonry<Item>({\r\n  // Measurement and layout\r\n  positioner,\r\n  resizeObserver,\r\n  // Grid items\r\n  items,\r\n  // Container props\r\n  as: ContainerComponent = 'div',\r\n  id,\r\n  className,\r\n  style,\r\n  role = 'grid',\r\n  tabIndex = 0,\r\n  containerRef,\r\n  // Item props\r\n  itemAs: ItemComponent = 'div',\r\n  itemStyle,\r\n  itemHeightEstimate = 300,\r\n  itemKey = defaultGetItemKey,\r\n  // Rendering props\r\n  overscanBy = 2,\r\n  scrollTop,\r\n  isScrolling,\r\n  height,\r\n  render: RenderComponent,\r\n  onRender,\r\n}: UseMasonryOptions<Item>) {\r\n  let startIndex = 0\r\n  let stopIndex: number | undefined = void 0\r\n  const forceUpdate = useForceUpdate()\r\n  const setItemRef = getRefSetter(positioner, resizeObserver)\r\n  const itemCount = items.length\r\n  const {\r\n    columnWidth,\r\n    columnCount,\r\n    range,\r\n    estimateHeight,\r\n    size,\r\n    shortestColumn,\r\n  } = positioner\r\n  const measuredCount = size()\r\n  const shortestColumnSize = shortestColumn()\r\n  const children: React.ReactElement[] = []\r\n  const itemRole = role + 'item'\r\n  const storedOnRender = useLatest(onRender)\r\n\r\n  overscanBy = height * overscanBy\r\n  const rangeEnd = scrollTop + overscanBy\r\n  const needsFreshBatch =\r\n    shortestColumnSize < rangeEnd && measuredCount < itemCount\r\n\r\n  range(\r\n    // We overscan in both directions because users scroll both ways,\r\n    // though one must admit scrolling down is more common and thus\r\n    // we only overscan by half the downward overscan amount\r\n    Math.max(0, scrollTop - overscanBy / 2),\r\n    rangeEnd,\r\n    (index, left, top) => {\r\n      const data = items[index]\r\n      const key = itemKey(data, index)\r\n      const phaseTwoStyle: React.CSSProperties = {\r\n        top,\r\n        left,\r\n        width: columnWidth,\r\n        writingMode: 'horizontal-tb',\r\n        position: 'absolute',\r\n      }\r\n\r\n      /* istanbul ignore next */\r\n      if (\r\n        typeof process !== 'undefined' &&\r\n        process.env.NODE_ENV !== 'production'\r\n      ) {\r\n        throwWithoutData(data, index)\r\n      }\r\n\r\n      children.push(\r\n        <ItemComponent\r\n          key={key}\r\n          ref={setItemRef(index)}\r\n          role={itemRole}\r\n          style={\r\n            typeof itemStyle === 'object' && itemStyle !== null\r\n              ? Object.assign({}, phaseTwoStyle, itemStyle)\r\n              : phaseTwoStyle\r\n          }\r\n        >\r\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\r\n        </ItemComponent>\r\n      )\r\n\r\n      if (stopIndex === void 0) {\r\n        startIndex = index\r\n        stopIndex = index\r\n      } else {\r\n        startIndex = Math.min(startIndex, index)\r\n        stopIndex = Math.max(stopIndex, index)\r\n      }\r\n    }\r\n  )\r\n\r\n  if (needsFreshBatch) {\r\n    const batchSize = Math.min(\r\n      itemCount - measuredCount,\r\n      Math.ceil(\r\n        ((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate) *\r\n          columnCount\r\n      )\r\n    )\r\n\r\n    let index = measuredCount\r\n    const phaseOneStyle = getCachedSize(columnWidth)\r\n\r\n    for (; index < measuredCount + batchSize; index++) {\r\n      const data = items[index]\r\n      const key = itemKey(data, index)\r\n\r\n      /* istanbul ignore next */\r\n      if (\r\n        typeof process !== 'undefined' &&\r\n        process.env.NODE_ENV !== 'production'\r\n      ) {\r\n        throwWithoutData(data, index)\r\n      }\r\n\r\n      children.push(\r\n        <ItemComponent\r\n          key={key}\r\n          ref={setItemRef(index)}\r\n          role={itemRole}\r\n          style={\r\n            typeof itemStyle === 'object'\r\n              ? Object.assign({}, phaseOneStyle, itemStyle)\r\n              : phaseOneStyle\r\n          }\r\n        >\r\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\r\n        </ItemComponent>\r\n      )\r\n    }\r\n  }\r\n\r\n  // Calls the onRender callback if the rendered indices changed\r\n  React.useEffect(() => {\r\n    if (typeof storedOnRender.current === 'function' && stopIndex !== void 0)\r\n      storedOnRender.current(startIndex, stopIndex, items)\r\n\r\n    didEverMount = '1'\r\n  }, [startIndex, stopIndex, items, storedOnRender])\r\n  // If we needed a fresh batch we should reload our components with the measured\r\n  // sizes\r\n  React.useEffect(() => {\r\n    if (needsFreshBatch) forceUpdate()\r\n    // eslint-disable-next-line\r\n  }, [needsFreshBatch])\r\n\r\n  // gets the container style object based upon the estimated height and whether or not\r\n  // the page is being scrolled\r\n  const containerStyle = getContainerStyle(\r\n    isScrolling,\r\n    estimateHeight(itemCount, itemHeightEstimate)\r\n  )\r\n\r\n  return (\r\n    <ContainerComponent\r\n      ref={containerRef}\r\n      key={didEverMount}\r\n      id={id}\r\n      role={role}\r\n      className={className}\r\n      tabIndex={tabIndex}\r\n      style={\r\n        typeof style === 'object'\r\n          ? assignUserStyle(containerStyle, style)\r\n          : containerStyle\r\n      }\r\n      children={children}\r\n    />\r\n  )\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction throwWithoutData(data: any, index: number) {\r\n  if (!data) {\r\n    throw new Error(\r\n      `No data was found at index: ${index}\\n\\n` +\r\n        `This usually happens when you've mutated or changed the \"items\" array in a ` +\r\n        `way that makes it shorter than the previous \"items\" array. Masonic knows nothing ` +\r\n        `about your underlying data and when it caches cell positions, it assumes you aren't ` +\r\n        `mutating the underlying \"items\".\\n\\n` +\r\n        `See https://codesandbox.io/s/masonic-w-react-router-example-2b5f9?file=/src/index.js for ` +\r\n        `an example that gets around this limitations. For advanced implementations, see ` +\r\n        `https://codesandbox.io/s/masonic-w-react-router-and-advanced-config-example-8em42?file=/src/index.js\\n\\n` +\r\n        `If this was the result of your removing an item from your \"items\", see this issue: ` +\r\n        `https://github.com/jaredLunde/masonic/issues/12`\r\n    )\r\n  }\r\n}\r\n\r\n// This is for triggering a remount after SSR has loaded in the client w/ hydrate()\r\nlet didEverMount = '0'\r\n\r\nexport interface UseMasonryOptions<Item> {\r\n  /**\r\n   * An array containing the data used by the grid items.\r\n   */\r\n  items: Item[]\r\n  /**\r\n   * A grid cell positioner and cache created by the `usePositioner()` hook or\r\n   * the `createPositioner` utility.\r\n   */\r\n  positioner: Positioner\r\n  /**\r\n   * A resize observer that tracks mutations to the grid cells and forces the\r\n   * Masonry grid to recalculate its layout if any cells affect column heights\r\n   * change. Check out the `useResizeObserver()` hook.\r\n   */\r\n  resizeObserver?: {\r\n    observe: ResizeObserver['observe']\r\n    disconnect: ResizeObserver['observe']\r\n    unobserve: ResizeObserver['unobserve']\r\n  }\r\n  /**\r\n   * This is the type of element the grid container will be rendered as.\r\n   * @default \"div\"`\r\n   */\r\n  as?: keyof JSX.IntrinsicElements | React.ComponentType<any>\r\n  /**\r\n   * Optionally gives the grid container an `id` prop.\r\n   */\r\n  id?: string\r\n  /**\r\n   * Optionally gives the grid container a `className` prop.\r\n   */\r\n  className?: string\r\n  /**\r\n   * Adds extra `style` attributes to the container in addition to those\r\n   * created by the `useMasonry()` hook.\r\n   */\r\n  style?: React.CSSProperties\r\n  /**\r\n   * Optionally swap out the accessibility `role` prop of the container and its items.\r\n   * @default \"grid\"\r\n   */\r\n  role?: 'grid' | 'list'\r\n  /**\r\n   * Change the `tabIndex` of the grid container.\r\n   * @default 0\r\n   */\r\n  tabIndex?: number\r\n  /**\r\n   * Forwards a React ref to the grid container.\r\n   */\r\n  containerRef?:\r\n    | ((element: HTMLElement) => void)\r\n    | React.MutableRefObject<HTMLElement | null>\r\n  /**\r\n   * This is the type of element the grid items will be rendered as.\r\n   * @default \"div\"\r\n   */\r\n  itemAs?: keyof JSX.IntrinsicElements | React.ComponentType<any>\r\n  /**\r\n   * Adds extra `style` attributes to the grid items in addition to those\r\n   * created by the `useMasonry()` hook.\r\n   */\r\n  itemStyle?: React.CSSProperties\r\n  /**\r\n   * This value is used for estimating the initial height of the masonry grid. It is important for\r\n   * the UX of the scrolling behavior and in determining how many `items` to render in a batch, so it's\r\n   * wise to set this value with some level accuracy, though it doesn't need to be perfect.\r\n   * @default 300\r\n   */\r\n  itemHeightEstimate?: number\r\n  /**\r\n   * The value returned here must be unique to the item. By default, the key is the item's index. This is ok\r\n   * if your collection of items is never modified. Setting this property ensures that the component in `render`\r\n   * is reused each time the masonry grid is reflowed. A common pattern would be to return the item's database\r\n   * ID here if there is one, e.g. `data => data.id`\r\n   * @default (data, index) => index`\r\n   */\r\n  itemKey?: (data: Item, index: number) => string | number\r\n  /**\r\n   * This number is used for determining the number of grid cells outside of the visible window to render.\r\n   * The default value is `2` which means \"render 2 windows worth (2 * `height`) of content before and after\r\n   * the items in the visible window\". A value of `3` would be 3 windows worth of grid cells, so it's a\r\n   * linear relationship.\r\n   *\r\n   * Overscanning is important for preventing tearing when scrolling through items in the grid, but setting\r\n   * too high of a vaimport { useForceUpdate } from './use-force-update';\r\nlue may create too much work for React to handle, so it's best that you tune this\r\n   * value accordingly.\r\n   * @default 2\r\n   */\r\n  overscanBy?: number\r\n\r\n  /**\r\n   * This is the height of the window. If you're rendering the grid relative to the browser `window`,\r\n   * the current `document.documentElement.clientHeight` is the value you'll want to set here. If you're\r\n   * rendering the grid inside of another HTML element, you'll want to provide the current `element.offsetHeight`\r\n   * here.\r\n   */\r\n  height: number\r\n  /**\r\n   * The current scroll progress in pixel of the window the grid is rendered in. If you're rendering\r\n   * the grid relative to the browser `window`, you'll want the most current `window.scrollY` here.\r\n   * If you're rendering the grid inside of another HTML element, you'll want the current `element.scrollTop`\r\n   * value here. The `useScroller()` hook and `<MasonryScroller>` components will help you if you're\r\n   * rendering the grid relative to the browser `window`.\r\n   */\r\n  scrollTop: number\r\n  /**\r\n   * This property is used for determining whether or not the grid container should add styles that\r\n   * dramatically increase scroll performance. That is, turning off `pointer-events` and adding a\r\n   * `will-change: contents;` value to the style string. You can forgo using this prop, but I would\r\n   * not recommend that. The `useScroller()` hook and `<MasonryScroller>` components will help you if\r\n   * you're rendering the grid relative to the browser `window`.\r\n   * @default false\r\n   */\r\n  isScrolling?: boolean\r\n  /**\r\n   * This component is rendered for each item of your `items` prop array. It should accept three props:\r\n   * `index`, `width`, and `data`. See RenderComponentProps.\r\n   */\r\n  render: React.ComponentType<RenderComponentProps<Item>>\r\n  /**\r\n   * This callback is invoked any time the items currently being rendered by the grid change.\r\n   */\r\n  onRender?: (\r\n    startIndex: number,\r\n    stopIndex: number | undefined,\r\n    items: Item[]\r\n  ) => void\r\n}\r\n\r\nexport interface RenderComponentProps<Item> {\r\n  /**\r\n   * The index of the cell in the `items` prop array.\r\n   */\r\n  index: number\r\n  /**\r\n   * The rendered width of the cell's column.\r\n   */\r\n  width: number\r\n  /**\r\n   * The data at `items[index]` of your `items` prop array.\r\n   */\r\n  data: Item\r\n}\r\n\r\n//\r\n// Render-phase utilities\r\n\r\n// ~5.5x faster than createElement without the memo\r\nconst createRenderElement = trieMemoize(\r\n  [OneKeyMap, {}, WeakMap, OneKeyMap],\r\n  (RenderComponent, index, data, columnWidth) => (\r\n    <RenderComponent index={index} data={data} width={columnWidth} />\r\n  )\r\n)\r\n\r\nconst getContainerStyle = memoizeOne(\r\n  (isScrolling: boolean | undefined, estimateHeight: number) => ({\r\n    position: 'relative',\r\n    width: '100%',\r\n    maxWidth: '100%',\r\n    height: Math.ceil(estimateHeight),\r\n    maxHeight: Math.ceil(estimateHeight),\r\n    willChange: isScrolling ? 'contents' : void 0,\r\n    pointerEvents: isScrolling ? 'none' : void 0,\r\n  })\r\n)\r\n\r\nconst cmp2 = (args: IArguments, pargs: IArguments | any[]): boolean =>\r\n  args[0] === pargs[0] && args[1] === pargs[1]\r\n\r\nconst assignUserStyle = memoizeOne(\r\n  (containerStyle, userStyle) => Object.assign({}, containerStyle, userStyle),\r\n  // @ts-ignore\r\n  cmp2\r\n)\r\n\r\nfunction defaultGetItemKey<Item>(_: Item, i: number) {\r\n  return i\r\n}\r\n\r\n// the below memoizations for for ensuring shallow equal is reliable for pure\r\n// component children\r\nconst getCachedSize = memoizeOne(\r\n  (width: number): React.CSSProperties => ({\r\n    width,\r\n    zIndex: -1000,\r\n    visibility: 'hidden',\r\n    position: 'absolute',\r\n    writingMode: 'horizontal-tb',\r\n  }),\r\n  (args, pargs) => args[0] === pargs[0]\r\n)\r\n\r\nconst getRefSetter = memoizeOne(\r\n  (\r\n    positioner: Positioner,\r\n    resizeObserver?: UseMasonryOptions<any>['resizeObserver']\r\n  ) => (index: number) => (el: HTMLElement | null): void => {\r\n    if (el === null) return\r\n    if (resizeObserver) {\r\n      resizeObserver.observe(el)\r\n      elementsCache.set(el, index)\r\n    }\r\n    if (positioner.get(index) === void 0) positioner.set(index, el.offsetHeight)\r\n  },\r\n  // @ts-ignore\r\n  cmp2\r\n)\r\n","import {useScroller} from './use-scroller'\r\nimport {useMasonry} from './use-masonry'\r\nimport type {UseMasonryOptions} from './use-masonry'\r\n/**\r\n * A heavily-optimized component that updates `useMasonry()` when the scroll position of the browser `window`\r\n * changes. This bare-metal component is used by `<Masonry>` under the hood.\r\n */\r\nexport function MasonryScroller<Item>(props: MasonryScrollerProps<Item>) {\r\n  // We put this in its own layer because it's the thing that will trigger the most updates\r\n  // and we don't want to slower ourselves by cycling through all the functions, objects, and effects\r\n  // of other hooks\r\n  const {scrollTop, isScrolling} = useScroller(props.offset, props.scrollFps)\r\n  // This is an update-heavy phase and while we could just Object.assign here,\r\n  // it is way faster to inline and there's a relatively low hit to he bundle\r\n  // size.\r\n  return useMasonry<Item>({\r\n    scrollTop,\r\n    isScrolling,\r\n    positioner: props.positioner,\r\n    resizeObserver: props.resizeObserver,\r\n    items: props.items,\r\n    onRender: props.onRender,\r\n    as: props.as,\r\n    id: props.id,\r\n    className: props.className,\r\n    style: props.style,\r\n    role: props.role,\r\n    tabIndex: props.tabIndex,\r\n    containerRef: props.containerRef,\r\n    itemAs: props.itemAs,\r\n    itemStyle: props.itemStyle,\r\n    itemHeightEstimate: props.itemHeightEstimate,\r\n    itemKey: props.itemKey,\r\n    overscanBy: props.overscanBy,\r\n    height: props.height,\r\n    render: props.render,\r\n  })\r\n}\r\n\r\nexport interface MasonryScrollerProps<Item>\r\n  extends Omit<UseMasonryOptions<Item>, 'scrollTop' | 'isScrolling'> {\r\n  /**\r\n   * This determines how often (in frames per second) to update the scroll position of the\r\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\r\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\r\n   * heavy `render` components it may be prudent to reduce this number.\r\n   * @default 12\r\n   */\r\n  scrollFps?: number\r\n  /**\r\n   * The vertical space in pixels between the top of the grid container and the top\r\n   * of the browser `document.documentElement`.\r\n   * @default 0\r\n   */\r\n  offset?: number\r\n}\r\n\r\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\r\n  MasonryScroller.displayName = 'MasonryScroller'\r\n}\r\n","import * as React from 'react'\r\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\r\n\r\n/**\r\n * A hook for measuring the width of the grid container, as well as its distance\r\n * from the top of the document. These values are necessary to correctly calculate the number/width\r\n * of columns to render, as well as the number of rows to render.\r\n *\r\n * @param elementRef A `ref` object created by `React.useRef()`. That ref should be provided to the\r\n *   `containerRef` property in `useMasonry()`.\r\n * @param deps You can force this hook to recalculate the `offset` and `width` whenever this\r\n *   dependencies list changes. A common dependencies list might look like `[windowWidth, windowHeight]`,\r\n *   which would force the hook to recalculate any time the size of the browser `window` changed.\r\n */\r\nexport function useContainerPosition(\r\n  elementRef: React.MutableRefObject<HTMLElement | null>,\r\n  deps: React.DependencyList = emptyArr\r\n): ContainerPosition {\r\n  const [containerPosition, setContainerPosition] = React.useState<\r\n    ContainerPosition\r\n  >({offset: 0, width: 0})\r\n\r\n  useLayoutEffect(() => {\r\n    const {current} = elementRef\r\n    if (current !== null) {\r\n      let offset = 0\r\n      let el = current\r\n\r\n      do {\r\n        offset += el.offsetTop || 0\r\n        el = el.offsetParent as HTMLElement\r\n      } while (el)\r\n\r\n      if (\r\n        offset !== containerPosition.offset ||\r\n        current.offsetWidth !== containerPosition.width\r\n      ) {\r\n        setContainerPosition({\r\n          offset,\r\n          width: current.offsetWidth,\r\n        })\r\n      }\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, deps)\r\n\r\n  return containerPosition\r\n}\r\n\r\nexport interface ContainerPosition {\r\n  /**\r\n   * The distance in pixels between the top of the element in `elementRef` and the top of\r\n   * the `document.documentElement`.\r\n   */\r\n  offset: number\r\n  /**\r\n   * The `offsetWidth` of the element in `elementRef`.\r\n   */\r\n  width: number\r\n}\r\n\r\nconst emptyArr: [] = []\r\n","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nexport default index;\n","import * as React from 'react'\r\nimport trieMemoize from 'trie-memoize'\r\nimport ResizeObserver from 'resize-observer-polyfill'\r\nimport {elementsCache} from './elements-cache'\r\nimport {useForceUpdate} from './use-force-update'\r\nimport type {Positioner} from './use-positioner'\r\n\r\n/**\r\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\r\n * made to cells affecting their height.\r\n *\r\n * @param positioner The masonry cell positioner created by the `usePositioner()` hook.\r\n */\r\nexport function useResizeObserver(positioner: Positioner) {\r\n  const forceUpdate = useForceUpdate()\r\n  const resizeObserver = createResizeObserver(positioner, forceUpdate)\r\n  // Cleans up the resize observers when they change or the\r\n  // component unmounts\r\n  React.useEffect(() => () => resizeObserver.disconnect(), [resizeObserver])\r\n  return resizeObserver\r\n}\r\n\r\n/**\r\n * Creates a resize observer that fires an `updater` callback whenever the height of\r\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\r\n *\r\n * @param positioner A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\r\n * @param updater A callback that fires whenever one or many cell heights change.\r\n */\r\nexport const createResizeObserver = trieMemoize(\r\n  [WeakMap],\r\n  // TODO: figure out a way to test this\r\n  /* istanbul ignore next */\r\n  (positioner: Positioner, updater: (updates: number[]) => void) =>\r\n    new ResizeObserver((entries) => {\r\n      const updates: number[] = []\r\n      let i = 0\r\n\r\n      for (; i < entries.length; i++) {\r\n        const entry = entries[i]\r\n        const height = (entry.target as HTMLElement).offsetHeight\r\n\r\n        if (height > 0) {\r\n          const index = elementsCache.get(entry.target)\r\n\r\n          if (index !== void 0) {\r\n            const position = positioner.get(index)\r\n\r\n            if (position !== void 0 && height !== position.height)\r\n              updates.push(index, height)\r\n          }\r\n        }\r\n      }\r\n\r\n      if (updates.length > 0) {\r\n        // Updates the size/positions of the cell with the resize\r\n        // observer updates\r\n        positioner.update(updates)\r\n        updater(updates)\r\n      }\r\n    })\r\n)\r\n\r\ninterface ResizeObserverEntryBoxSize {\r\n  blockSize: number\r\n  inlineSize: number\r\n}\r\n\r\ninterface NativeResizeObserverEntry extends ResizeObserverEntry {\r\n  borderBoxSize: ResizeObserverEntryBoxSize\r\n  contentBoxSize: ResizeObserverEntryBoxSize\r\n}\r\n","type Color = 0 | 1 | 2\r\nconst RED = 0\r\nconst BLACK = 1\r\nconst NIL = 2\r\n\r\nconst DELETE = 0\r\nconst KEEP = 1\r\n\r\ntype ListNode = {\r\n  index: number\r\n  high: number\r\n  next: ListNode | null\r\n}\r\n\r\ninterface TreeNode {\r\n  max: number\r\n  low: number\r\n  high: number\r\n  // color\r\n  C: Color\r\n  // P\r\n  P: TreeNode\r\n  // right\r\n  R: TreeNode\r\n  // left\r\n  L: TreeNode\r\n  list: ListNode\r\n}\r\n\r\ninterface Tree {\r\n  root: TreeNode\r\n  size: number\r\n}\r\n\r\nfunction addInterval(treeNode: TreeNode, high: number, index: number): boolean {\r\n  let node: ListNode | null = treeNode.list\r\n  let prevNode: ListNode | undefined\r\n\r\n  while (node) {\r\n    if (node.index === index) return false\r\n    if (high > node.high) break\r\n    prevNode = node\r\n    node = node.next\r\n  }\r\n\r\n  if (!prevNode) treeNode.list = {index, high, next: node}\r\n  if (prevNode) prevNode.next = {index, high, next: prevNode.next}\r\n\r\n  return true\r\n}\r\n\r\nfunction removeInterval(treeNode: TreeNode, index: number) {\r\n  let node: ListNode | null = treeNode.list\r\n  if (node.index === index) {\r\n    if (node.next === null) return DELETE\r\n    treeNode.list = node.next\r\n    return KEEP\r\n  }\r\n\r\n  let prevNode: ListNode | undefined = node\r\n  node = node.next\r\n\r\n  while (node !== null) {\r\n    if (node.index === index) {\r\n      prevNode.next = node.next\r\n      return KEEP\r\n    }\r\n    prevNode = node\r\n    node = node.next\r\n  }\r\n}\r\n\r\nconst NULL_NODE: TreeNode = {\r\n  low: 0,\r\n  max: 0,\r\n  high: 0,\r\n  C: NIL,\r\n  // @ts-ignore\r\n  P: undefined,\r\n  // @ts-ignore\r\n  R: undefined,\r\n  // @ts-ignore\r\n  L: undefined,\r\n  // @ts-ignore\r\n  list: undefined,\r\n}\r\n\r\nNULL_NODE.P = NULL_NODE\r\nNULL_NODE.L = NULL_NODE\r\nNULL_NODE.R = NULL_NODE\r\n\r\nfunction updateMax(node: TreeNode) {\r\n  const max = node.high\r\n  if (node.L === NULL_NODE && node.R === NULL_NODE) node.max = max\r\n  else if (node.L === NULL_NODE) node.max = Math.max(node.R.max, max)\r\n  else if (node.R === NULL_NODE) node.max = Math.max(node.L.max, max)\r\n  else node.max = Math.max(Math.max(node.L.max, node.R.max), max)\r\n}\r\n\r\nfunction updateMaxUp(node: TreeNode) {\r\n  let x = node\r\n\r\n  while (x.P !== NULL_NODE) {\r\n    updateMax(x.P)\r\n    x = x.P\r\n  }\r\n}\r\n\r\nfunction rotateLeft(tree: Tree, x: TreeNode) {\r\n  if (x.R === NULL_NODE) return\r\n  const y = x.R\r\n  x.R = y.L\r\n  if (y.L !== NULL_NODE) y.L.P = x\r\n  y.P = x.P\r\n\r\n  if (x.P === NULL_NODE) tree.root = y\r\n  else {\r\n    if (x === x.P.L) x.P.L = y\r\n    else x.P.R = y\r\n  }\r\n\r\n  y.L = x\r\n  x.P = y\r\n\r\n  updateMax(x)\r\n  updateMax(y)\r\n}\r\n\r\nfunction rotateRight(tree: Tree, x: TreeNode) {\r\n  if (x.L === NULL_NODE) return\r\n  const y = x.L\r\n  x.L = y.R\r\n  if (y.R !== NULL_NODE) y.R.P = x\r\n  y.P = x.P\r\n\r\n  if (x.P === NULL_NODE) tree.root = y\r\n  else {\r\n    if (x === x.P.R) x.P.R = y\r\n    else x.P.L = y\r\n  }\r\n\r\n  y.R = x\r\n  x.P = y\r\n\r\n  updateMax(x)\r\n  updateMax(y)\r\n}\r\n\r\nfunction replaceNode(tree: Tree, x: TreeNode, y: TreeNode) {\r\n  if (x.P === NULL_NODE) tree.root = y\r\n  else if (x === x.P.L) x.P.L = y\r\n  else x.P.R = y\r\n  y.P = x.P\r\n}\r\n\r\nfunction fixRemove(tree: Tree, x: TreeNode) {\r\n  let w\r\n\r\n  while (x !== NULL_NODE && x.C === BLACK) {\r\n    if (x === x.P.L) {\r\n      w = x.P.R\r\n\r\n      if (w.C === RED) {\r\n        w.C = BLACK\r\n        x.P.C = RED\r\n        rotateLeft(tree, x.P)\r\n        w = x.P.R\r\n      }\r\n\r\n      if (w.L.C === BLACK && w.R.C === BLACK) {\r\n        w.C = RED\r\n        x = x.P\r\n      } else {\r\n        if (w.R.C === BLACK) {\r\n          w.L.C = BLACK\r\n          w.C = RED\r\n          rotateRight(tree, w)\r\n          w = x.P.R\r\n        }\r\n\r\n        w.C = x.P.C\r\n        x.P.C = BLACK\r\n        w.R.C = BLACK\r\n        rotateLeft(tree, x.P)\r\n        x = tree.root\r\n      }\r\n    } else {\r\n      w = x.P.L\r\n\r\n      if (w.C === RED) {\r\n        w.C = BLACK\r\n        x.P.C = RED\r\n        rotateRight(tree, x.P)\r\n        w = x.P.L\r\n      }\r\n\r\n      if (w.R.C === BLACK && w.L.C === BLACK) {\r\n        w.C = RED\r\n        x = x.P\r\n      } else {\r\n        if (w.L.C === BLACK) {\r\n          w.R.C = BLACK\r\n          w.C = RED\r\n          rotateLeft(tree, w)\r\n          w = x.P.L\r\n        }\r\n\r\n        w.C = x.P.C\r\n        x.P.C = BLACK\r\n        w.L.C = BLACK\r\n        rotateRight(tree, x.P)\r\n        x = tree.root\r\n      }\r\n    }\r\n  }\r\n\r\n  x.C = BLACK\r\n}\r\n\r\nfunction minimumTree(x: TreeNode) {\r\n  while (x.L !== NULL_NODE) x = x.L\r\n  return x\r\n}\r\n\r\nfunction fixInsert(tree: Tree, z: TreeNode) {\r\n  let y: TreeNode\r\n  while (z.P.C === RED) {\r\n    if (z.P === z.P.P.L) {\r\n      y = z.P.P.R\r\n\r\n      if (y.C === RED) {\r\n        z.P.C = BLACK\r\n        y.C = BLACK\r\n        z.P.P.C = RED\r\n        z = z.P.P\r\n      } else {\r\n        if (z === z.P.R) {\r\n          z = z.P\r\n          rotateLeft(tree, z)\r\n        }\r\n\r\n        z.P.C = BLACK\r\n        z.P.P.C = RED\r\n        rotateRight(tree, z.P.P)\r\n      }\r\n    } else {\r\n      y = z.P.P.L\r\n\r\n      if (y.C === RED) {\r\n        z.P.C = BLACK\r\n        y.C = BLACK\r\n        z.P.P.C = RED\r\n        z = z.P.P\r\n      } else {\r\n        if (z === z.P.L) {\r\n          z = z.P\r\n          rotateRight(tree, z)\r\n        }\r\n\r\n        z.P.C = BLACK\r\n        z.P.P.C = RED\r\n        rotateLeft(tree, z.P.P)\r\n      }\r\n    }\r\n  }\r\n  tree.root.C = BLACK\r\n}\r\n\r\ninterface IIntervalTree {\r\n  insert(low: number, high: number, index: number): void\r\n  remove(index: number): void\r\n  search(\r\n    low: number,\r\n    high: number,\r\n    callback: (index: number, low: number) => any\r\n  ): void\r\n  size: number\r\n}\r\n\r\nexport function createIntervalTree(): IIntervalTree {\r\n  const tree = {\r\n    root: NULL_NODE,\r\n    size: 0,\r\n  }\r\n  // we know these indexes are a consistent, safe way to make look ups\r\n  // for our case so it's a solid O(1) alternative to\r\n  // the O(log n) searchNode() in typical interval trees\r\n  const indexMap: Record<number, TreeNode> = {}\r\n\r\n  return {\r\n    insert(low, high, index) {\r\n      let x: TreeNode = tree.root\r\n      let y: TreeNode = NULL_NODE\r\n\r\n      while (x !== NULL_NODE) {\r\n        y = x\r\n        if (low === y.low) break\r\n        if (low < x.low) x = x.L\r\n        else x = x.R\r\n      }\r\n\r\n      if (low === y.low && y !== NULL_NODE) {\r\n        if (!addInterval(y, high, index)) return\r\n        y.high = Math.max(y.high, high)\r\n        updateMax(y)\r\n        updateMaxUp(y)\r\n        indexMap[index] = y\r\n        tree.size++\r\n        return\r\n      }\r\n\r\n      const z: TreeNode = {\r\n        low,\r\n        high,\r\n        max: high,\r\n        C: RED,\r\n        P: y,\r\n        L: NULL_NODE,\r\n        R: NULL_NODE,\r\n        list: {index, high, next: null},\r\n      }\r\n\r\n      if (y === NULL_NODE) {\r\n        tree.root = z\r\n      } else {\r\n        if (z.low < y.low) y.L = z\r\n        else y.R = z\r\n        updateMaxUp(z)\r\n      }\r\n\r\n      fixInsert(tree, z)\r\n      indexMap[index] = z\r\n      tree.size++\r\n    },\r\n\r\n    remove(index) {\r\n      const z = indexMap[index]\r\n      if (z === void 0) return\r\n      delete indexMap[index]\r\n\r\n      const intervalResult = removeInterval(z, index)\r\n      if (intervalResult === void 0) return\r\n      if (intervalResult === KEEP) {\r\n        z.high = z.list.high\r\n        updateMax(z)\r\n        updateMaxUp(z)\r\n        tree.size--\r\n        return\r\n      }\r\n\r\n      let y = z\r\n      let originalYColor = y.C\r\n      let x: TreeNode\r\n\r\n      if (z.L === NULL_NODE) {\r\n        x = z.R\r\n        replaceNode(tree, z, z.R)\r\n      } else if (z.R === NULL_NODE) {\r\n        x = z.L\r\n        replaceNode(tree, z, z.L)\r\n      } else {\r\n        y = minimumTree(z.R)\r\n        originalYColor = y.C\r\n        x = y.R\r\n\r\n        if (y.P === z) {\r\n          x.P = y\r\n        } else {\r\n          replaceNode(tree, y, y.R)\r\n          y.R = z.R\r\n          y.R.P = y\r\n        }\r\n\r\n        replaceNode(tree, z, y)\r\n        y.L = z.L\r\n        y.L.P = y\r\n        y.C = z.C\r\n      }\r\n\r\n      updateMax(x)\r\n      updateMaxUp(x)\r\n\r\n      if (originalYColor === BLACK) fixRemove(tree, x)\r\n      tree.size--\r\n    },\r\n\r\n    search(low, high, callback) {\r\n      const stack = [tree.root]\r\n      while (stack.length !== 0) {\r\n        const node = stack.pop() as TreeNode\r\n        if (node === NULL_NODE || low > node.max) continue\r\n        if (node.L !== NULL_NODE) stack.push(node.L)\r\n        if (node.R !== NULL_NODE) stack.push(node.R)\r\n        if (node.low <= high && node.high >= low) {\r\n          let curr: ListNode | null = node.list\r\n          while (curr !== null) {\r\n            if (curr.high >= low) callback(curr.index, node.low)\r\n            curr = curr.next\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    get size() {\r\n      return tree.size\r\n    },\r\n  }\r\n}\r\n","import * as React from 'react'\r\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\r\nimport {createIntervalTree} from './interval-tree'\r\n\r\n/**\r\n * This hook creates the grid cell positioner and cache required by `useMasonry()`. This is\r\n * the meat of the grid's layout algorithm, determining which cells to render at a given scroll\r\n * position, as well as where to place new items in the grid.\r\n *\r\n * @param options Properties that determine the number of columns in the grid, as well\r\n *  as their widths.\r\n * @param deps This hook will create a new positioner, clearing all existing cached positions,\r\n *  whenever the dependencies in this list change.\r\n */\r\nexport function usePositioner(\r\n  {\r\n    width,\r\n    columnWidth = 200,\r\n    columnGutter = 0,\r\n    columnCount,\r\n  }: UsePositionerOptions,\r\n  deps: React.DependencyList = emptyArr\r\n): Positioner {\r\n  const initPositioner = (): Positioner => {\r\n    const [computedColumnWidth, computedColumnCount] = getColumns(\r\n      width,\r\n      columnWidth,\r\n      columnGutter,\r\n      columnCount\r\n    )\r\n    return createPositioner(\r\n      computedColumnCount,\r\n      computedColumnWidth,\r\n      columnGutter\r\n    )\r\n  }\r\n  const [positioner, setPositioner] = React.useState<Positioner>(initPositioner)\r\n  const didMount = React.useRef(0)\r\n\r\n  // Create a new positioner when the dependencies change\r\n  useLayoutEffect(() => {\r\n    if (didMount.current) setPositioner(initPositioner())\r\n    didMount.current = 1\r\n    // eslint-disable-next-line\r\n  }, deps)\r\n\r\n  // Updates the item positions any time a prop potentially affecting their\r\n  // size changes\r\n  useLayoutEffect(() => {\r\n    if (didMount.current) {\r\n      const cacheSize = positioner.size()\r\n      const nextPositioner = initPositioner()\r\n      let index = 0\r\n\r\n      for (; index < cacheSize; index++) {\r\n        const pos = positioner.get(index)\r\n        nextPositioner.set(index, pos !== void 0 ? pos.height : 0)\r\n      }\r\n\r\n      setPositioner(nextPositioner)\r\n    }\r\n    // eslint-disable-next-line\r\n  }, [width, columnWidth, columnGutter, columnCount])\r\n\r\n  return positioner\r\n}\r\n\r\nexport interface UsePositionerOptions {\r\n  /**\r\n   * The width of the container you're rendering the grid within, i.e. the container\r\n   * element's `element.offsetWidth`\r\n   */\r\n  width: number\r\n  /**\r\n   * The minimum column width. The `usePositioner()` hook will automatically size the\r\n   * columns to fill their container based upon the `columnWidth` and `columnGutter` values.\r\n   * It will never render anything smaller than this width unless its container itself is\r\n   * smaller than its value. This property is optional if you're using a static `columnCount`.\r\n   * @default 200\r\n   */\r\n  columnWidth?: number\r\n  /**\r\n   * This sets the vertical and horizontal space between grid cells in pixels.\r\n   */\r\n  columnGutter?: number\r\n  /**\r\n   * By default, `usePositioner()` derives the column count from the `columnWidth`, `columnGutter`,\r\n   * and `width` props. However, in some situations it is nice to be able to override that behavior\r\n   * (e.g. creating a `List` component).\r\n   */\r\n  columnCount?: number\r\n}\r\n\r\n/**\r\n * Creates a cell positioner for the `useMasonry()` hook. The `usePositioner()` hook uses\r\n * this utility under the hood.\r\n *\r\n * @param columnCount The number of columns in the grid\r\n * @param columnWidth The width of each column in the grid\r\n * @param columnGutter The amount of horizontal and vertical space in pixels to render\r\n *  between each grid item.\r\n */\r\nexport const createPositioner = (\r\n  columnCount: number,\r\n  columnWidth: number,\r\n  columnGutter = 0\r\n): Positioner => {\r\n  // O(log(n)) lookup of cells to render for a given viewport size\r\n  // Store tops and bottoms of each cell for fast intersection lookup.\r\n  const intervalTree = createIntervalTree()\r\n  // Track the height of each column.\r\n  // Layout algorithm below always inserts into the shortest column.\r\n  const columnHeights: number[] = new Array(columnCount)\r\n  // Used for O(1) item access\r\n  const items: PositionerItem[] = []\r\n  // Tracks the item indexes within an individual column\r\n  const columnItems: number[][] = new Array(columnCount)\r\n\r\n  for (let i = 0; i < columnCount; i++) {\r\n    columnHeights[i] = 0\r\n    columnItems[i] = []\r\n  }\r\n\r\n  return {\r\n    columnCount,\r\n    columnWidth,\r\n    set: (index, height = 0) => {\r\n      let column = 0\r\n\r\n      // finds the shortest column and uses it\r\n      for (let i = 1; i < columnHeights.length; i++) {\r\n        if (columnHeights[i] < columnHeights[column]) column = i\r\n      }\r\n\r\n      const top = columnHeights[column] || 0\r\n      columnHeights[column] = top + height + columnGutter\r\n      columnItems[column].push(index)\r\n      items[index] = {\r\n        left: column * (columnWidth + columnGutter),\r\n        top,\r\n        height,\r\n        column,\r\n      }\r\n      intervalTree.insert(top, top + height, index)\r\n    },\r\n    get: (index) => items[index],\r\n    // This only updates items in the specific columns that have changed, on and after the\r\n    // specific items that have changed\r\n    update: (updates) => {\r\n      const columns: number[] = new Array(columnCount)\r\n      let i = 0,\r\n        j = 0\r\n\r\n      // determines which columns have items that changed, as well as the minimum index\r\n      // changed in that column, as all items after that index will have their positions\r\n      // affected by the change\r\n      for (; i < updates.length - 1; i++) {\r\n        const index = updates[i]\r\n        const item = items[index]\r\n        item.height = updates[++i]\r\n        intervalTree.remove(index)\r\n        intervalTree.insert(item.top, item.top + item.height, index)\r\n        columns[item.column] =\r\n          columns[item.column] === void 0\r\n            ? index\r\n            : Math.min(index, columns[item.column])\r\n      }\r\n\r\n      for (i = 0; i < columns.length; i++) {\r\n        // bails out if the column didn't change\r\n        if (columns[i] === void 0) continue\r\n        const itemsInColumn = columnItems[i]\r\n        // the index order is sorted with certainty so binary search is a great solution\r\n        // here as opposed to Array.indexOf()\r\n        const startIndex = binarySearch(itemsInColumn, columns[i])\r\n        const index = columnItems[i][startIndex]\r\n        const startItem = items[index]\r\n        columnHeights[i] = startItem.top + startItem.height + columnGutter\r\n\r\n        for (j = startIndex + 1; j < itemsInColumn.length; j++) {\r\n          const index = itemsInColumn[j]\r\n          const item = items[index]\r\n          item.top = columnHeights[i]\r\n          columnHeights[i] = item.top + item.height + columnGutter\r\n          intervalTree.remove(index)\r\n          intervalTree.insert(item.top, item.top + item.height, index)\r\n        }\r\n      }\r\n    },\r\n    // Render all cells visible within the viewport range defined.\r\n    range: (lo, hi, renderCallback) =>\r\n      intervalTree.search(lo, hi, (index, top) =>\r\n        renderCallback(index, items[index].left, top)\r\n      ),\r\n    estimateHeight: (itemCount, defaultItemHeight): number => {\r\n      const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights))\r\n\r\n      return itemCount === intervalTree.size\r\n        ? tallestColumn\r\n        : tallestColumn +\r\n            Math.ceil((itemCount - intervalTree.size) / columnCount) *\r\n              defaultItemHeight\r\n    },\r\n    shortestColumn: () => {\r\n      if (columnHeights.length > 1) return Math.min.apply(null, columnHeights)\r\n      return columnHeights[0] || 0\r\n    },\r\n    size(): number {\r\n      return intervalTree.size\r\n    },\r\n  }\r\n}\r\n\r\nexport interface Positioner {\r\n  /**\r\n   * The number of columns in the grid\r\n   */\r\n  columnCount: number\r\n  /**\r\n   * The width of each column in the grid\r\n   */\r\n  columnWidth: number\r\n  /**\r\n   * Sets the position for the cell at `index` based upon the cell's height\r\n   */\r\n  set: (index: number, height: number) => void\r\n  /**\r\n   * Gets the `PositionerItem` for the cell at `index`\r\n   */\r\n  get: (index: number) => PositionerItem | undefined\r\n  /**\r\n   * Updates cells based on their indexes and heights\r\n   * positioner.update([index, height, index, height, index, height...])\r\n   */\r\n  update: (updates: number[]) => void\r\n  /**\r\n   * Searches the interval tree for grid cells with a `top` value in\r\n   * betwen `lo` and `hi` and invokes the callback for each item that\r\n   * is discovered\r\n   */\r\n  range: (\r\n    lo: number,\r\n    hi: number,\r\n    renderCallback: (index: number, left: number, top: number) => void\r\n  ) => void\r\n  /**\r\n   * Returns the number of grid cells in the cache\r\n   */\r\n\r\n  size: () => number\r\n  /**\r\n   * Estimates the total height of the grid\r\n   */\r\n\r\n  estimateHeight: (itemCount: number, defaultItemHeight: number) => number\r\n  /**\r\n   * Returns the height of the shortest column in the grid\r\n   */\r\n\r\n  shortestColumn: () => number\r\n}\r\n\r\nexport interface PositionerItem {\r\n  /**\r\n   * This is how far from the top edge of the grid container in pixels the\r\n   * item is placed\r\n   */\r\n  top: number\r\n  /**\r\n   * This is how far from the left edge of the grid container in pixels the\r\n   * item is placed\r\n   */\r\n  left: number\r\n  /**\r\n   * This is the height of the grid cell\r\n   */\r\n  height: number\r\n  /**\r\n   * This is the column number containing the grid cell\r\n   */\r\n  column: number\r\n}\r\n\r\n/* istanbul ignore next */\r\nconst binarySearch = (a: number[], y: number): number => {\r\n  let l = 0\r\n  let h = a.length - 1\r\n\r\n  while (l <= h) {\r\n    const m = (l + h) >>> 1\r\n    const x = a[m]\r\n    if (x === y) return m\r\n    else if (x <= y) l = m + 1\r\n    else h = m - 1\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\nconst getColumns = (\r\n  width = 0,\r\n  minimumWidth = 0,\r\n  gutter = 8,\r\n  columnCount?: number\r\n): [number, number] => {\r\n  columnCount = columnCount || Math.floor(width / (minimumWidth + gutter)) || 1\r\n  const columnWidth = Math.floor(\r\n    (width - gutter * (columnCount - 1)) / columnCount\r\n  )\r\n  return [columnWidth, columnCount]\r\n}\r\n\r\nconst emptyArr: [] = []\r\n","import * as React from 'react'\r\nimport useLatest from '@react-hook/latest'\r\nimport useEvent from '@react-hook/event'\r\nimport {useThrottleCallback} from '@react-hook/throttle'\r\nimport type {Positioner, PositionerItem} from './use-positioner'\r\n\r\n/**\r\n * A hook that creates a callback for scrolling to a specific index in\r\n * the \"items\" array.\r\n *\r\n * @param positioner A positioner created by the `usePositioner()` hook\r\n * @param options Configuration options\r\n */\r\nexport function useScrollToIndex(\r\n  positioner: Positioner,\r\n  options: UseScrollToIndexOptions\r\n) {\r\n  const {\r\n    align = 'top',\r\n    element = typeof window !== 'undefined' && window,\r\n    offset = 0,\r\n    height = typeof window !== 'undefined' ? window.innerHeight : 0,\r\n  } = options\r\n  const latestOptions = useLatest({\r\n    positioner,\r\n    element,\r\n    align,\r\n    offset,\r\n    height,\r\n  } as const)\r\n  const getTarget = React.useRef(() => {\r\n    const latestElement = latestOptions.current.element\r\n    return latestElement && 'current' in latestElement\r\n      ? latestElement.current\r\n      : latestElement\r\n  }).current\r\n  const [state, dispatch] = React.useReducer(\r\n    (\r\n      state: {\r\n        position: PositionerItem | undefined\r\n        index: number | undefined\r\n        prevTop: number | undefined\r\n      },\r\n      action:\r\n        | {type: 'scrollToIndex'; value: number | undefined}\r\n        | {type: 'setPosition'; value: PositionerItem | undefined}\r\n        | {type: 'setPrevTop'; value: number | undefined}\r\n        | {type: 'reset'}\r\n    ) => {\r\n      const nextState = {\r\n        position: state.position,\r\n        index: state.index,\r\n        prevTop: state.prevTop,\r\n      }\r\n\r\n      /* istanbul ignore next */\r\n      if (action.type === 'scrollToIndex') {\r\n        return {\r\n          position: latestOptions.current.positioner.get(action.value ?? -1),\r\n          index: action.value,\r\n          prevTop: void 0,\r\n        }\r\n      } else if (action.type === 'setPosition') {\r\n        nextState.position = action.value\r\n      } else if (action.type === 'setPrevTop') {\r\n        nextState.prevTop = action.value\r\n      } else if (action.type === 'reset') {\r\n        return defaultState\r\n      }\r\n\r\n      return nextState\r\n    },\r\n    defaultState\r\n  )\r\n  const throttledDispatch = useThrottleCallback(dispatch, 15)\r\n\r\n  // If we find the position along the way we can immediately take off\r\n  // to the correct spot.\r\n  useEvent(getTarget() as Window, 'scroll', () => {\r\n    if (!state.position && state.index) {\r\n      const position = latestOptions.current.positioner.get(state.index)\r\n\r\n      if (position) {\r\n        dispatch({type: 'setPosition', value: position})\r\n      }\r\n    }\r\n  })\r\n\r\n  // If the top changes out from under us in the case of dynamic cells, we\r\n  // want to keep following it.\r\n  const currentTop =\r\n    state.index !== void 0 &&\r\n    latestOptions.current.positioner.get(state.index)?.top\r\n\r\n  React.useEffect(() => {\r\n    const target = getTarget()\r\n    if (!target) return\r\n    const {height, align, offset, positioner} = latestOptions.current\r\n\r\n    if (state.position) {\r\n      let scrollTop = state.position.top\r\n\r\n      if (align === 'bottom') {\r\n        scrollTop = scrollTop - height + state.position.height\r\n      } else if (align === 'center') {\r\n        scrollTop -= (height - state.position.height) / 2\r\n      }\r\n\r\n      target.scrollTo(0, Math.max(0, (scrollTop += offset)))\r\n      // Resets state after 400ms, an arbitrary time I determined to be\r\n      // still visually pleasing if there is a slow network reply in dynamic\r\n      // cells\r\n      let didUnsubscribe = false\r\n      const timeout = setTimeout(\r\n        () => !didUnsubscribe && dispatch({type: 'reset'}),\r\n        400\r\n      )\r\n      return () => {\r\n        didUnsubscribe = true\r\n        clearTimeout(timeout)\r\n      }\r\n    } else if (state.index !== void 0) {\r\n      // Estimates the top based upon the average height of current cells\r\n      let estimatedTop =\r\n        (positioner.shortestColumn() / positioner.size()) * state.index\r\n      if (state.prevTop)\r\n        estimatedTop = Math.max(estimatedTop, state.prevTop + height)\r\n      target.scrollTo(0, estimatedTop)\r\n      throttledDispatch({type: 'setPrevTop', value: estimatedTop})\r\n    }\r\n  }, [currentTop, state, latestOptions, getTarget, throttledDispatch])\r\n\r\n  return React.useRef((index: number) => {\r\n    dispatch({type: 'scrollToIndex', value: index})\r\n  }).current\r\n}\r\n\r\nconst defaultState = {\r\n  index: void 0,\r\n  position: void 0,\r\n  prevTop: void 0,\r\n} as const\r\n\r\nexport type UseScrollToIndexOptions = {\r\n  /**\r\n   * The window element or a React ref for the window element. That is,\r\n   * this is the grid container.\r\n   * @default window\r\n   */\r\n  element?: Window | HTMLElement | React.RefObject<HTMLElement> | null\r\n  /**\r\n   * Sets the vertical alignment of the cell within the grid container.\r\n   * @default \"top\"\r\n   */\r\n  align?: 'center' | 'top' | 'bottom'\r\n  /**\r\n   * The height of the grid.\r\n   * @default window.innerHeight\r\n   */\r\n  height?: number\r\n  /**\r\n   * The vertical space in pixels between the top of the grid container and the top\r\n   * of the window.\r\n   * @default 0\r\n   */\r\n  offset?: number\r\n}\r\n","import * as React from 'react'\r\nimport {useWindowSize} from '@react-hook/window-size'\r\nimport {MasonryScroller} from './masonry-scroller'\r\nimport type {MasonryScrollerProps} from './masonry-scroller'\r\nimport {useContainerPosition} from './use-container-position'\r\nimport {useResizeObserver} from './use-resize-observer'\r\nimport {usePositioner} from './use-positioner'\r\nimport type {UsePositionerOptions} from './use-positioner'\r\nimport {useScrollToIndex} from './use-scroll-to-index'\r\nimport type {UseScrollToIndexOptions} from './use-scroll-to-index'\r\n\r\n/**\r\n * A \"batteries included\" masonry grid which includes all of the implementation details below. This component is the\r\n * easiest way to get off and running in your app, before switching to more advanced implementations, if necessary.\r\n * It will change its column count to fit its container's width and will decide how many rows to render based upon\r\n * the height of the browser `window`.\r\n */\r\nexport function Masonry<Item>(props: MasonryProps<Item>) {\r\n  const containerRef = React.useRef<null | HTMLElement>(null)\r\n  const windowSize = useWindowSize({\r\n    initialWidth: props.ssrWidth,\r\n    initialHeight: props.ssrHeight,\r\n  })\r\n  const containerPos = useContainerPosition(containerRef, windowSize)\r\n  const nextProps = Object.assign(\r\n    {\r\n      offset: containerPos.offset,\r\n      width: containerPos.width || windowSize[0],\r\n      height: windowSize[1],\r\n      containerRef,\r\n    },\r\n    props\r\n  ) as any\r\n  nextProps.positioner = usePositioner(nextProps)\r\n  nextProps.resizeObserver = useResizeObserver(nextProps.positioner)\r\n  const scrollToIndex = useScrollToIndex(nextProps.positioner, {\r\n    height: nextProps.height,\r\n    offset: containerPos.offset,\r\n    align:\r\n      typeof props.scrollToIndex === 'object'\r\n        ? props.scrollToIndex.align\r\n        : void 0,\r\n  })\r\n  const index =\r\n    props.scrollToIndex &&\r\n    (typeof props.scrollToIndex === 'number'\r\n      ? props.scrollToIndex\r\n      : props.scrollToIndex.index)\r\n\r\n  React.useEffect(() => {\r\n    if (index !== void 0) scrollToIndex(index)\r\n  }, [index, scrollToIndex])\r\n\r\n  return React.createElement(MasonryScroller, nextProps)\r\n}\r\n\r\nexport interface MasonryProps<Item>\r\n  extends Omit<\r\n      MasonryScrollerProps<Item>,\r\n      'offset' | 'width' | 'height' | 'containerRef' | 'positioner'\r\n    >,\r\n    Pick<UsePositionerOptions, 'columnWidth' | 'columnGutter' | 'columnCount'> {\r\n  /**\r\n   * Scrolls to a given index within the grid. The grid will re-scroll\r\n   * any time the index changes.\r\n   */\r\n  scrollToIndex?:\r\n    | number\r\n    | {\r\n        index: number\r\n        align: UseScrollToIndexOptions['align']\r\n      }\r\n  /**\r\n   * This is the width that will be used for the browser `window` when rendering this component in SSR.\r\n   * This prop isn't relevant for client-side only apps.\r\n   */\r\n  ssrWidth?: number\r\n  /**\r\n   * This is the height that will be used for the browser `window` when rendering this component in SSR.\r\n   * This prop isn't relevant for client-side only apps.\r\n   */\r\n  ssrHeight?: number\r\n  /**\r\n   * This determines how often (in frames per second) to update the scroll position of the\r\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\r\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\r\n   * heavy `render` components it may be prudent to reduce this number.\r\n   * @default 12\r\n   */\r\n  scrollFps?: number\r\n}\r\n\r\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\r\n  Masonry.displayName = 'Masonry'\r\n}\r\n","import {useDebounce} from '@react-hook/debounce'\nimport useEvent from '@react-hook/event'\n\nconst emptyObj = {}\n\nexport interface DebouncedWindowSizeOptions {\n  initialWidth?: number\n  initialHeight?: number\n  wait?: number\n  leading?: boolean\n}\n\nconst win = typeof window === 'undefined' ? null : window\nconst getSize = () =>\n  [\n    document.documentElement.clientWidth,\n    document.documentElement.clientHeight,\n  ] as const\n\nexport const useWindowSize = (\n  options: DebouncedWindowSizeOptions = emptyObj\n): readonly [number, number] => {\n  const {wait, leading, initialWidth = 0, initialHeight = 0} = options\n  const [size, setDebouncedSize] = useDebounce<readonly [number, number]>(\n    /* istanbul ignore next */\n    typeof document === 'undefined' ? [initialWidth, initialHeight] : getSize,\n    wait,\n    leading\n  )\n  const setSize = (): void => setDebouncedSize(getSize)\n\n  useEvent(win, 'resize', setSize)\n  useEvent(win, 'orientationchange', setSize)\n\n  return size\n}\n\nexport const useWindowHeight = (\n  options?: Omit<DebouncedWindowSizeOptions, 'initialWidth'>\n): number => useWindowSize(options)[1]\n\nexport const useWindowWidth = (\n  options?: Omit<DebouncedWindowSizeOptions, 'initialHeight'>\n): number => useWindowSize(options)[0]\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\nexport const useDebounceCallback = <CallbackArgs extends any[]>(\n  callback: (...args: CallbackArgs) => void,\n  wait = 100,\n  leading = false\n): ((...args: CallbackArgs) => void) => {\n  const storedCallback = useLatest(callback)\n  const timeout = React.useRef<ReturnType<typeof setTimeout>>()\n  const deps = [wait, leading, storedCallback]\n  // Cleans up pending timeouts when the deps change\n  React.useEffect(\n    () => () => {\n      timeout.current && clearTimeout(timeout.current)\n      timeout.current = void 0\n    },\n    deps\n  )\n\n  return React.useCallback(function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args = arguments\n    const {current} = timeout\n    // Calls on leading edge\n    if (current === void 0 && leading) {\n      timeout.current = setTimeout(() => {\n        timeout.current = void 0\n      }, wait)\n      // eslint-disable-next-line prefer-spread\n      return storedCallback.current.apply(null, args as any)\n    }\n    // Clear the timeout every call and start waiting again\n    current && clearTimeout(current)\n    // Waits for `wait` before invoking the callback\n    timeout.current = setTimeout(() => {\n      timeout.current = void 0\n      storedCallback.current.apply(null, args as any)\n    }, wait)\n  }, deps)\n}\n\nexport const useDebounce = <State extends any>(\n  initialState: State | (() => State),\n  wait?: number,\n  leading?: boolean\n): [State, React.Dispatch<React.SetStateAction<State>>] => {\n  const state = React.useState(initialState)\n  return [state[0], useDebounceCallback(state[1], wait, leading)]\n}\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  storedValue.current = current\n  return storedValue\n}\n\nexport default useLatest\n","import * as React from 'react'\n\nconst usePassiveLayoutEffect =\n  React[\n    typeof document !== 'undefined' && document.createElement !== void 0\n      ? 'useLayoutEffect'\n      : 'useEffect'\n  ]\n\nexport default usePassiveLayoutEffect\n","export type Raf = (callback: (timestamp: number) => void) => number\nexport type Caf = (handle: number) => void\n\nlet u = 'undefined',\n  win = typeof window !== u ? window : ({} as any),\n  p = typeof performance !== u ? performance : Date,\n  now = () => p.now(),\n  af = 'AnimationFrame' as const,\n  Caf = 'cancel' + af,\n  Raf = 'request' + af,\n  raf: Raf = win[Raf] && win[Raf].bind(win),\n  caf: Caf = win[Caf] && win[Caf].bind(win)\n\nif (!raf || !caf) {\n  let lastTime = 0\n  raf = (callback: FrameRequestCallback) => {\n    let curr = now(),\n      next = Math.max(lastTime + 1000 / 60, curr)\n    return setTimeout(() => {\n      callback((lastTime = next))\n    }, next - curr) as any\n  }\n  caf = (h) => clearTimeout(h)\n}\n\nexport {raf, caf, now}\n","export interface MapLike {\n  new (...args: any[]): any\n}\n\nexport type CacheConstructor =\n  | MapConstructor\n  | WeakMapConstructor\n  | MapLike\n  | Record<any, any>\n\ninterface Cache<K = any, V = any> {\n  set: (k: K, v: V) => V\n  get: (k: K) => V\n}\n\nconst createCache = (obj: CacheConstructor): Cache => {\n  try {\n    // @ts-ignore\n    return new obj()\n  } catch (e) {\n    const cache: Record<string, any> = {}\n\n    return {\n      set(k, v): void {\n        cache[k] = v\n      },\n      get(k): any {\n        return cache[k]\n      },\n    }\n  }\n}\n\nconst memo = (\n  constructors: CacheConstructor[]\n): {s: Cache['set']; g: Cache['get']} => {\n  const depth = constructors.length,\n    baseCache = createCache(constructors[0])\n  let base: any\n  let map: any\n  let i: number\n  let node: typeof baseCache\n  const one = depth === 1\n  // quicker access for one and two-argument functions\n  const g1 = (args: IArguments): any =>\n    (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1])\n  const s1 = (args: IArguments, value: any): any => {\n    if (one) baseCache.set(args[0], value)\n    else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1])\n        map.set(args[1], value)\n        baseCache.set(args[0], map)\n      } else {\n        base.set(args[1], value)\n      }\n    }\n\n    return value\n  }\n\n  const g2 = (args: IArguments): any => {\n    node = baseCache\n\n    for (i = 0; i < depth; i++)\n      if ((node = node.get(args[i])) === void 0) return\n\n    return node\n  }\n\n  const s2 = (args: IArguments, value: any): any => {\n    node = baseCache\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1])\n        node.set(args[i], map)\n        node = map\n      } else {\n        node = map\n      }\n    }\n\n    node.set(args[depth - 1], value)\n    return value\n  }\n\n  return depth < 3 ? {g: g1, s: s1} : {g: g2, s: s2}\n}\n\nconst memoize = <T extends any[], U extends any>(\n  mapConstructors: CacheConstructor[],\n  fn: (...args: T) => U\n): ((...args: T) => U) => {\n  let item: U\n  const {g, s} = memo(mapConstructors)\n  return function () {\n    return (item = g(arguments)) === void 0\n      ? s(arguments, fn.apply(null, arguments as any))\n      : item\n  }\n}\n\nexport default memoize\n","class OneKeyMap<K extends any = any, V extends any = any> {\n  set: (k: K, v: V) => void\n  get: (k: K) => V | undefined\n\n  constructor() {\n    let key: K | undefined, val: V | undefined\n    this.get = (k: K): V | undefined => (k === key ? val : void 0)\n    this.set = (k: K, v: V): void => {\n      key = k\n      val = v\n    }\n  }\n}\n\nexport default OneKeyMap\n","const memoOne = <Args extends any[], T extends any>(\n  fn: (...args: Args) => T,\n  areEqual?: AreEqual<Args>\n): OutputFunction<Args, T> => {\n  const equal = areEqual || defaultAreEqual\n  let args: Args, value: any\n\n  return function (): T {\n    return !!args && equal(arguments as any, args)\n      ? value\n      : (value = fn.apply(null, (args = arguments as any)))\n  } as OutputFunction<Args, T>\n}\n\nexport default memoOne\n\nconst defaultAreEqual = (\n  current: IArguments,\n  prev: IArguments | any[]\n): boolean =>\n  current[0] === prev[0] &&\n  current[1] === prev[1] &&\n  current[2] === prev[2] &&\n  current[3] === prev[3]\n\nexport type AreEqual<Args> = (currentArgs: Args, prevArgs: Args) => boolean\nexport type InputFunction = (...args: any[]) => any\nexport type OutputFunction<Args extends any[], T extends any> = (\n  ...args: Args\n) => T\n","export const elementsCache: WeakMap<Element, number> = new Map()\r\n","import * as React from 'react'\r\nimport useLatest from '@react-hook/latest'\r\n\r\n/**\r\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\r\n * hook invokes a callback each time the last rendered index surpasses the total number of items\r\n * in your items array or the number defined in the `totalItems` option.\r\n *\r\n * @param loadMoreItems This callback is invoked when more rows must be loaded. It will be used to\r\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\r\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\r\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\r\n *  as well.\r\n * @param options\r\n */\r\nexport function useInfiniteLoader<Item, T extends LoadMoreItemsCallback<Item>>(\r\n  loadMoreItems: T,\r\n  options: UseInfiniteLoaderOptions<Item> = emptyObj\r\n): LoadMoreItemsCallback<Item> {\r\n  const {\r\n    isItemLoaded,\r\n    minimumBatchSize = 16,\r\n    threshold = 16,\r\n    totalItems = 9e9,\r\n  } = options\r\n  const storedLoadMoreItems = useLatest(loadMoreItems)\r\n  const storedIsItemLoaded = useLatest(isItemLoaded)\r\n\r\n  return React.useCallback(\r\n    (startIndex, stopIndex, items) => {\r\n      const unloadedRanges = scanForUnloadedRanges(\r\n        storedIsItemLoaded.current,\r\n        minimumBatchSize,\r\n        items,\r\n        totalItems,\r\n        Math.max(0, startIndex - threshold),\r\n        Math.min(totalItems - 1, (stopIndex || 0) + threshold)\r\n      )\r\n      // The user is responsible for memoizing their loadMoreItems() function\r\n      // because we don't want to make assumptions about how they want to deal\r\n      // with `items`\r\n      for (let i = 0; i < unloadedRanges.length - 1; ++i)\r\n        storedLoadMoreItems.current(\r\n          unloadedRanges[i],\r\n          unloadedRanges[++i],\r\n          items\r\n        )\r\n    },\r\n    [\r\n      totalItems,\r\n      minimumBatchSize,\r\n      threshold,\r\n      storedLoadMoreItems,\r\n      storedIsItemLoaded,\r\n    ]\r\n  )\r\n}\r\n\r\n/**\r\n * Returns all of the ranges within a larger range that contain unloaded rows.\r\n */\r\nfunction scanForUnloadedRanges<Item>(\r\n  isItemLoaded: UseInfiniteLoaderOptions<\r\n    Item\r\n  >['isItemLoaded'] = defaultIsItemLoaded,\r\n  minimumBatchSize: UseInfiniteLoaderOptions<Item>['minimumBatchSize'] = 16,\r\n  items: any[],\r\n  totalItems: UseInfiniteLoaderOptions<Item>['totalItems'] = 9e9,\r\n  startIndex: number,\r\n  stopIndex: number\r\n): number[] {\r\n  const unloadedRanges: number[] = []\r\n  let rangeStartIndex: number | undefined,\r\n    rangeStopIndex: number | undefined,\r\n    index = startIndex\r\n\r\n  /* istanbul ignore next */\r\n  for (; index <= stopIndex; index++) {\r\n    if (!isItemLoaded(index, items)) {\r\n      rangeStopIndex = index\r\n      if (rangeStartIndex === void 0) rangeStartIndex = index\r\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\r\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex)\r\n      rangeStartIndex = rangeStopIndex = void 0\r\n    }\r\n  }\r\n\r\n  // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\r\n  // Scan forward to try filling our :minimumBatchSize.\r\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\r\n    const potentialStopIndex = Math.min(\r\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\r\n      totalItems - 1\r\n    )\r\n\r\n    /* istanbul ignore next */\r\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\r\n      if (!isItemLoaded(index, items)) {\r\n        rangeStopIndex = index\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n\r\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex)\r\n  }\r\n\r\n  // Check to see if our first range ended prematurely.\r\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\r\n  /* istanbul ignore next */\r\n  if (unloadedRanges.length) {\r\n    let firstUnloadedStart = unloadedRanges[0]\r\n    const firstUnloadedStop = unloadedRanges[1]\r\n\r\n    while (\r\n      firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize &&\r\n      firstUnloadedStart > 0\r\n    ) {\r\n      const index = firstUnloadedStart - 1\r\n\r\n      if (!isItemLoaded(index, items)) {\r\n        unloadedRanges[0] = firstUnloadedStart = index\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  return unloadedRanges\r\n}\r\n\r\nconst defaultIsItemLoaded = <Item>(index: number, items: Item[]): boolean =>\r\n  items[index] !== void 0\r\n\r\nexport interface UseInfiniteLoaderOptions<Item> {\r\n  /**\r\n   *  A callback responsible for determining the loaded state of each item. Should return `true`\r\n   * if the item has already been loaded and `false` if not.\r\n   * @default (index: number, items: any[]) => boolean\r\n   */\r\n  isItemLoaded?: (index: number, items: Item[]) => boolean\r\n  /**\r\n   * The minimum number of new items to be loaded at a time.  This property can be used to\r\n   * batch requests and reduce HTTP requests.\r\n   * @default 16\r\n   */\r\n  minimumBatchSize?: number\r\n  /**\r\n   * The threshold at which to pre-fetch data. A threshold X means that new data should start\r\n   * loading when a user scrolls within X cells of the end of your `items` array.\r\n   * @default 16\r\n   */\r\n  threshold?: number\r\n  /**\r\n   * The total number of items you'll need to eventually load (if known). This can\r\n   * be arbitrarily high if not known.\r\n   * @default 9e9\r\n   */\r\n  totalItems?: number\r\n}\r\n\r\nexport type LoadMoreItemsCallback<Item> = (\r\n  startIndex: number,\r\n  stopIndex: number,\r\n  items: Item[]\r\n) => any\r\n\r\nconst emptyObj = {}\r\n","import * as React from 'react'\r\nimport {Masonry} from './masonry'\r\nimport type {MasonryProps} from './masonry'\r\n\r\n/**\r\n * This is just a single-column `<Masonry>` component with `rowGutter` prop instead of\r\n * a `columnGutter` prop.\r\n */\r\nexport function List<Item>(props: ListProps<Item>) {\r\n  return (\r\n    <Masonry<Item>\r\n      role='list'\r\n      columnGutter={props.rowGutter}\r\n      columnCount={1}\r\n      columnWidth={1}\r\n      {...props}\r\n    />\r\n  )\r\n}\r\n\r\nexport interface ListProps<Item>\r\n  extends Omit<\r\n    MasonryProps<Item>,\r\n    'columGutter' | 'columnCount' | 'columnWidth'\r\n  > {\r\n  /**\r\n   * The amount of vertical space in pixels to add between the list cells.\r\n   * @default 0\r\n   */\r\n  rowGutter?: number\r\n}\r\n\r\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\r\n  List.displayName = 'List'\r\n}\r\n"],"names":["useEvent","target","type","listener","cleanup","storedListener","useLatest","storedCleanup","useLayoutEffect","didUnsubscribe","args","current","apply","this","targetEl","addEventListener","removeEventListener","useThrottleCallback","callback","fps","leading","prev","clearTrailing","storedCallback","ms","React","trailingTimeout","clearTimeout","deps","arguments","rightNow","now","call","setTimeout","useScroller","offset","setIsScrolling","scrollTop","state","initialState","useThrottle","window","getScrollY","win","useScrollPosition","isScrolling","didMount","fn","start","handle","to","v","raf","loop","caf","clearRequestTimeout","Math","max","useForceUpdate","setState","emptyObj","useMasonry","positioner","resizeObserver","items","as","ContainerComponent","id","className","style","role","tabIndex","containerRef","itemAs","ItemComponent","itemStyle","itemHeightEstimate","itemKey","defaultGetItemKey","overscanBy","height","RenderComponent","render","onRender","startIndex","stopIndex","forceUpdate","setItemRef","getRefSetter","itemCount","length","columnWidth","columnCount","range","estimateHeight","size","shortestColumn","measuredCount","shortestColumnSize","children","itemRole","storedOnRender","rangeEnd","needsFreshBatch","index","left","top","data","key","phaseTwoStyle","width","writingMode","position","push","__reactCreateElement__","ref","_extends","createRenderElement","min","batchSize","ceil","phaseOneStyle","getCachedSize","didEverMount","containerStyle","getContainerStyle","assignUserStyle","_","i","MasonryScroller","props","scrollFps","useContainerPosition","elementRef","emptyArr","containerPosition","setContainerPosition","el","offsetTop","offsetParent","offsetWidth","getIndex","arr","result","some","entry","class_1","__entries__","value","entries","splice","ctx","_i","_a","Date","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","bind","refresh","resolvePending","leadingCall","trailingCall","proxy","timeoutCallback","requestAnimationFrame$1","timeStamp","lastCallTime","throttle","observer","indexOf","connect_","observers","disconnect_","updateObservers_","gatherActive","hasActive","broadcastActive","activeObservers","filter","forEach","isBrowser","document","mutationObserverSupported","MutationObserver","observe","attributes","childList","characterData","subtree","disconnect","_b","propertyName","transitionKeys","instance_","toFloat","parseFloat","getBordersSize","styles","positions","reduce","getWindowOf","SVGGraphicsElement","SVGElement","getBBox","getContentRect","isSVGGraphicsElement","bbox","createRectInit","getSVGContentRect","clientWidth","clientHeight","emptyRect","getComputedStyle","paddings","positions_1","getPaddings","horizPad","right","vertPad","bottom","boxSizing","round","documentElement","isDocumentElement","vertScrollbar","horizScrollbar","abs","getHTMLElementContentRect","x","y","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","rect","ResizeObserverEntry","rectInit","Constr","contentRect","DOMRectReadOnly","Object","create","prototype","defineConfigurable","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","MapShim","TypeError","callback_","controller_","callbackCtx_","Element","observations","has","set","addObserver","delete","removeObserver","clearActive","clear","_this","observation","isActive","broadcastRect","map","useResizeObserver","createResizeObserver","updateMax","node","high","L","NULL_NODE","R","updateMaxUp","P","rotateLeft","tree","root","rotateRight","replaceNode","usePositioner","columnGutter","initPositioner","getColumns","computedColumnWidth","computedColumnCount","createPositioner","setPositioner","cacheSize","nextPositioner","pos","get","useScrollToIndex","options","align","element","innerHeight","latestOptions","getTarget","latestElement","action","nextState","prevTop","defaultState","dispatch","throttledDispatch","currentTop","_latestOptions$curren","scrollTo","timeout","estimatedTop","Masonry","windowSize","wait","initialWidth","initialHeight","useDebounceCallback","useDebounce","getSize","setDebouncedSize","setSize","useWindowSize","ssrWidth","ssrHeight","containerPos","nextProps","scrollToIndex","storedValue","usePassiveLayoutEffect","createElement","perf","performance","scrollY","pageYOffset","u","p","af","Caf","Raf","lastTime","curr","next","h","createCache","obj","e","cache","k","memoize","mapConstructors","item","constructors","base","depth","baseCache","one","g","s","OneKeyMap","val","memoOne","areEqual","equal","defaultAreEqual","elementsCache","Map","trieMemoize","WeakMap","memoizeOne","maxWidth","maxHeight","willChange","pointerEvents","cmp2","pargs","userStyle","zIndex","visibility","offsetHeight","defineProperty","enumerable","configurable","global$1","global","self","Function","requestAnimationFrame","getInstance","keys","writable","ownerDocument","defaultView","unobserve","ResizeObserver","method","updater","updates","update","low","C","undefined","list","intervalTree","indexMap","insert","treeNode","prevNode","addInterval","z","fixInsert","remove","intervalResult","removeInterval","originalYColor","minimumTree","w","fixRemove","search","stack","pop","createIntervalTree","columnHeights","Array","columnItems","column","columns","j","itemsInColumn","binarySearch","startItem","lo","hi","renderCallback","defaultItemHeight","tallestColumn","a","l","m","minimumWidth","gutter","floor","defaultIsItemLoaded","rowGutter","loadMoreItems","isItemLoaded","minimumBatchSize","threshold","totalItems","storedLoadMoreItems","storedIsItemLoaded","unloadedRanges","rangeStartIndex","rangeStopIndex","potentialStopIndex","firstUnloadedStart","firstUnloadedStop","scanForUnloadedRanges"],"mappings":"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"}